# PCA Workflow

Principal Component Analysis (PCA) workflow for reducing 56+ acoustic indices to key components that explain biodiversity patterns.

## Overview

PCA helps us answer: "Can we reduce 56+ acoustic indices to 3-5 'super indices' that capture most of the variation in our data?"

**Goal**: Identify the minimum set of indices needed for biodiversity assessment while maintaining predictive power.

## Step 1: Data Preparation

### Load Processed Data

```python
import pandas as pd
import numpy as np
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler

# Load acoustic indices data (generated by pipeline)
indices_df = pd.read_json('processed/indices/indices_combined.json')

# Load species detection data for correlation analysis
detections_df = pd.read_json('processed/detections/detections_combined.json')
```

### Quality Filtering

```python
# Remove indices with too much missing data
missing_threshold = 0.3  # 30% missing data threshold
valid_indices = indices_df.columns[indices_df.isnull().mean() < missing_threshold]

# Remove indices with near-zero variance  
variance_threshold = 0.01
low_variance_indices = indices_df[valid_indices].var()
informative_indices = low_variance_indices[low_variance_indices > variance_threshold].index

print(f"Filtered from {len(indices_df.columns)} to {len(informative_indices)} indices")
```

## Step 2: Standardization

PCA requires standardized data because indices have different scales:

```python
# Standardize indices (mean=0, std=1)
scaler = StandardScaler()
indices_standardized = scaler.fit_transform(indices_df[informative_indices].fillna(0))

# Convert back to DataFrame for easier handling
indices_scaled = pd.DataFrame(
    indices_standardized, 
    columns=informative_indices,
    index=indices_df.index
)
```

## Step 3: PCA Analysis

### Fit PCA Model

```python
# Fit PCA (we'll analyze all components first)
pca = PCA()
pca_scores = pca.fit_transform(indices_scaled)

# Calculate cumulative explained variance
cumulative_variance = np.cumsum(pca.explained_variance_ratio_)

# Find number of components for 70% variance threshold
n_components_70 = np.argmax(cumulative_variance >= 0.70) + 1
print(f"Components needed for 70% variance: {n_components_70}")
```

### Extract Key Results

```python
# Component loadings (how each index contributes to each component)
loadings = pd.DataFrame(
    pca.components_[:n_components_70].T,
    columns=[f'PC{i+1}' for i in range(n_components_70)],
    index=informative_indices
)

# Component scores (transformed data)
scores = pd.DataFrame(
    pca_scores[:, :n_components_70],
    columns=[f'PC{i+1}' for i in range(n_components_70)],
    index=indices_df.index
)

# Explained variance
explained_var = pd.DataFrame({
    'Component': [f'PC{i+1}' for i in range(n_components_70)],
    'Explained_Variance': pca.explained_variance_ratio_[:n_components_70],
    'Cumulative_Variance': cumulative_variance[:n_components_70]
})
```

## Step 4: Component Interpretation

### Identify Dominant Indices per Component

```python
# Find top contributing indices for each component
def get_top_indices(component_col, n_top=5):
    """Get top N indices contributing to a component (by absolute loading)"""
    abs_loadings = component_col.abs().sort_values(ascending=False)
    return abs_loadings.head(n_top)

# Analyze each component
for col in loadings.columns:
    print(f"\n{col} - {explained_var[explained_var['Component']==col]['Explained_Variance'].iloc[0]:.1%} variance")
    top_indices = get_top_indices(loadings[col])
    
    for idx, loading in top_indices.items():
        print(f"  {idx}: {loading:.3f}")
```

### Component Naming and Interpretation

Based on the dominant indices, assign biological meanings to components:

```python
# Example component interpretations (will vary with actual data)
component_interpretations = {
    'PC1': 'General Activity Level (temporal variance indices dominant)',
    'PC2': 'Frequency Complexity (spectral diversity indices dominant)',  
    'PC3': 'Bioacoustic Activity (biological vs anthropogenic separation)',
    'PC4': 'Low Frequency Activity (marine mammal-related indices)',
    'PC5': 'High Frequency Activity (crustacean-related indices)'
}
```

## Step 5: Index Selection

### High-Loading Indices

Identify the specific indices that contribute most to key components:

```python
# Get the most important individual indices across all components
index_importance = loadings.abs().max(axis=1).sort_values(ascending=False)

# Select top indices that together represent major components
n_super_indices = 8  # Target number of indices to retain
super_indices = index_importance.head(n_super_indices).index

print("Super Indices Selected:")
for idx in super_indices:
    max_component = loadings.loc[idx].abs().idxmax()
    max_loading = loadings.loc[idx, max_component]
    print(f"  {idx}: {max_loading:.3f} on {max_component}")
```

### Validation of Reduced Set

```python
# Test if reduced index set captures similar variance
pca_reduced = PCA()
reduced_scores = pca_reduced.fit_transform(indices_scaled[super_indices])

# Compare variance explanation
original_var_70 = cumulative_variance[n_components_70-1] 
reduced_var = np.cumsum(pca_reduced.explained_variance_ratio_)

print(f"Original {n_components_70} components: {original_var_70:.1%} variance")
print(f"Reduced {len(super_indices)} indices: {reduced_var[min(len(super_indices)-1, len(reduced_var)-1)]:.1%} variance")
```

## Step 6: Species Correlation Analysis

Test how well PCA components predict species detection patterns:

```python
# Merge PCA scores with species detection data
merged_data = scores.join(detections_df, how='inner')

# Calculate correlations between PC scores and species detections
species_cols = [col for col in detections_df.columns if col not in ['station', 'year', 'date', 'date_time']]
pc_cols = [f'PC{i+1}' for i in range(n_components_70)]

# Correlation matrix
correlations = merged_data[pc_cols + species_cols].corr().loc[pc_cols, species_cols]

# Find species best predicted by each component
for pc in pc_cols:
    top_species = correlations.loc[pc].abs().sort_values(ascending=False).head(3)
    print(f"\n{pc} most correlated with:")
    for species, corr in top_species.items():
        print(f"  {species}: {corr:.3f}")
```

## Step 7: Export Results

Save analysis results for dashboard and further analysis:

```python
import json
import os

# Create analysis output directory
os.makedirs('analysis/pca/', exist_ok=True)

# Save loadings matrix
loadings.to_json('analysis/pca/pca_loadings.json', orient='records')

# Save component scores  
scores.to_json('analysis/pca/pca_scores.json', orient='records')

# Save explained variance
explained_var.to_json('analysis/pca/explained_variance.json', orient='records')

# Save super indices selection
super_indices_info = {
    'selected_indices': list(super_indices),
    'selection_method': 'highest_loading_across_components',
    'n_components_analyzed': n_components_70,
    'variance_threshold': 0.70,
    'component_interpretations': component_interpretations
}

with open('analysis/pca/super_indices.json', 'w') as f:
    json.dump(super_indices_info, f, indent=2)

print("PCA analysis results saved to analysis/pca/")
```

## Interpretation Guidelines

### Understanding Component Loadings
- **High absolute loading (>0.5)**: Index strongly contributes to component
- **Near zero loading (<0.1)**: Index doesn't contribute to component  
- **Sign matters**: Positive vs negative loadings indicate opposite patterns

### Biological Meaning
Components often represent:
- **PC1**: Overall acoustic activity level
- **PC2**: Frequency domain complexity
- **PC3**: Temporal pattern diversity
- **PC4+**: More specific patterns (frequency bands, biological vs anthropogenic)

### Quality Indicators
- **70% variance threshold**: Industry standard for sufficient dimensionality reduction
- **Scree plot**: Look for "elbow" where additional components add little variance
- **Component interpretability**: Can we assign biological meaning to each component?

## Next Steps

1. **[Validate with species data](../for-scientists/data-analysis.md#phase-4-correlation-analysis)** - Test component-species relationships
2. **[Environmental correction](../data/structure.md)** - Account for temperature/depth effects
3. **[Dashboard visualization](../for-developers/architecture.md)** - Explore results interactively

The PCA workflow provides the foundation for identifying which acoustic indices are most informative for biodiversity assessment, enabling more efficient monitoring strategies.