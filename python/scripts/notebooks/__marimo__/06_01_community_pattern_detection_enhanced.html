<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.16.0/dist/favicon.ico" />
    <!-- Preload is necessary because we show these images when we disconnect from the server,
    but at that point we cannot load these images from the server -->
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.16.0/dist/assets/gradient-yHQUC_QB.png" as="image" />
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.16.0/dist/assets/noise-60BoTA8O.png" as="image" />
    <!-- Preload the fonts -->
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.16.0/dist/assets/Lora-VariableFont_wght-B2ootaw-.ttf" as="font" crossorigin="anonymous" />
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.16.0/dist/assets/PTSans-Regular-CxL0S8W7.ttf" as="font" crossorigin="anonymous" />
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.16.0/dist/assets/PTSans-Bold-D9fedIX3.ttf" as="font" crossorigin="anonymous" />
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.16.0/dist/assets/FiraMono-Regular-BTCkDNvf.ttf" as="font" crossorigin="anonymous" />
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.16.0/dist/assets/FiraMono-Medium-DU3aDxX5.ttf" as="font" crossorigin="anonymous" />
    <link rel="preload" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.16.0/dist/assets/FiraMono-Bold-CLVRCuM9.ttf" as="font" crossorigin="anonymous" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta name="description" content="a marimo app" />
    <link rel="apple-touch-icon" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.16.0/dist/apple-touch-icon.png" />
    <link rel="manifest" crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.16.0/dist/manifest.json" />

    <script data-marimo="true">
      function __resizeIframe(obj) {
        var scrollbarHeight = 20; // Max between windows, mac, and linux

        function setHeight() {
          var element = obj.contentWindow.document.documentElement;
          // If there is no vertical scrollbar, we don't need to resize the iframe
          if (element.scrollHeight === element.clientHeight) {
            return;
          }

          // Create a new height that includes the scrollbar height if it's visible
          var hasHorizontalScrollbar = element.scrollWidth > element.clientWidth;
          var newHeight = element.scrollHeight + (hasHorizontalScrollbar ? scrollbarHeight : 0);

          // Only update the height if it's different from the current height
          if (obj.style.height !== `${newHeight}px`) {
            obj.style.height = `${newHeight}px`;
          }
        }

        // Resize the iframe to the height of the content and bottom scrollbar height
        setHeight();

        // Resize the iframe when the content changes
        const resizeObserver = new ResizeObserver((entries) => {
          setHeight();
        });
        resizeObserver.observe(obj.contentWindow.document.body);
      }
    </script>
    <marimo-filename hidden>06_01_community_pattern_detection_enhanced.py</marimo-filename>
    <!-- TODO(Trevor): Legacy, required by VS Code plugin. Remove when plugin is updated (see marimo/server/_templates/template.py) -->
    <marimo-version data-version="{{ version }}" hidden></marimo-version>
    <marimo-user-config data-config="{{ user_config }}" hidden></marimo-user-config>
    <marimo-server-token data-token="{{ server_token }}" hidden></marimo-server-token>
    <!-- /TODO -->
    <title>06 01 community pattern detection enhanced</title>
    <script type="module" crossorigin crossorigin="anonymous" src="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.16.0/dist/assets/index-DKEudB02.js"></script>
    <link rel="stylesheet" crossorigin crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/@marimo-team/frontend@0.16.0/dist/assets/index-Cx0bsY1w.css">
  
<script data-marimo="true">
    window.__MARIMO_STATIC__ = {};
    window.__MARIMO_STATIC__.files = {};
</script>
</head>
  <body>
    <div id="root"></div>
    <!-- This is a portal for the data editor to render in -->
    <div id="portal" data-testid="glide-portal" style="position: fixed; left: 0; top: 0; z-index: 9999"></div>
    <script data-marimo="true">
      window.__MARIMO_MOUNT_CONFIG__ = {
            "filename": "06_01_community_pattern_detection_enhanced.py",
            "mode": "read",
            "version": "0.16.0",
            "serverToken": "static",
            "config": {"ai": {"models": {"custom_models": [], "displayed_models": []}}, "completion": {"activate_on_typing": true, "copilot": false}, "display": {"cell_output": "above", "code_editor_font_size": 14, "dataframes": "rich", "default_table_max_columns": 50, "default_table_page_size": 10, "default_width": "medium", "reference_highlighting": false, "theme": "light"}, "formatting": {"line_length": 79}, "keymap": {"overrides": {}, "preset": "default"}, "language_servers": {"pylsp": {"enable_flake8": false, "enable_mypy": true, "enable_pydocstyle": false, "enable_pyflakes": false, "enable_pylint": false, "enable_ruff": true, "enabled": true}}, "package_management": {"manager": "pip"}, "runtime": {"auto_instantiate": true, "auto_reload": "off", "default_sql_output": "auto", "on_cell_change": "autorun", "output_max_bytes": 8000000, "reactive_tests": true, "std_stream_max_bytes": 1000000, "watcher_on_save": "lazy"}, "save": {"autosave": "after_delay", "autosave_delay": 1000, "format_on_save": false}, "server": {"browser": "default", "follow_symlink": false}, "snippets": {"custom_paths": [], "include_default_snippets": true}},
            "configOverrides": {},
            "appConfig": {"sql_output": "auto", "width": "medium"},
            "view": {"showAppCode": true},
            "notebook": {"cells": [{"code": "import marimo as mo\nmo.md(\n    r\"\"\"\n    # Notebook 6.1: Enhanced Community Pattern Detection with Transue Methodology\n\n    **Purpose**: Demonstrate that acoustic indices can detect community-level fish patterns using both traditional and state-of-the-art marine bioacoustics methodologies\n\n    **Key Outputs**: Comparative analysis using both Mutual Information and Boruta feature selection with Transue et al. (2023) statistical validation\n\n    **Methodological Enhancement**: This notebook builds upon the original community detection approach by integrating the Random Forest + Boruta methodology established by Transue et al. (2023) for Charleston Harbor soundscape analysis, while maintaining our original Mutual Information approach for comparison.\n\n    ---\n\n    ## Overview\n\n    This enhanced analysis combines two complementary feature selection approaches:\n\n    ### 1. Mutual Information Approach (Original)\n    - **What it does**: Detects non-linear relationships between acoustic indices and biological activity\n    - **Strength**: Captures complex, threshold-based biological relationships\n    - **Best for**: Discovering unexpected acoustic-biological connections\n\n    ### 2. Boruta + Random Forest Approach (Transue et al. 2023)\n    - **What it does**: Uses ensemble decision trees to identify all relevant features\n    - **Strength**: Established methodology for marine bioacoustics research\n    - **Best for**: Consistent, interpretable feature selection aligned with field standards\n\n    ## Why Use Both Approaches?\n\n    **Complementary Insights**: \n    - Mutual Information might find acoustic indices that respond to biological \"hotspots\" or threshold events\n    - Boruta might identify indices that consistently track biological patterns across all activity levels\n    - Comparing results validates feature importance across different statistical frameworks\n\n    **Scientific Rigor**: \n    - Shows our findings are robust across multiple analytical approaches\n    - Aligns with established marine bioacoustics methodology (Transue et al.)\n    - Provides comprehensive feature evaluation for biological screening applications\n\n    ## Enhanced Validation Framework\n\n    Following Transue et al. (2023), we implement:\n    - **Random Forest modeling** as the primary analytical framework\n    - **Boruta feature selection** for systematic feature importance\n    - **Out-of-bag validation** and cross-validation for robust performance estimates\n    - **Dunnett-Tukey-Kramer post-hoc testing** for statistical significance validation\n\n    The key question remains: **\"Can acoustic indices tell us when to pay attention?\"** but now with enhanced methodological rigor.\n    \"\"\"\n)", "code_hash": "76d4331613b8a0dfae89ef9e3e1604a4", "config": {"column": null, "disabled": false, "hide_code": true}, "id": "Hbol", "name": "_"}, {"code": "import pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom pathlib import Path\nimport warnings\nimport json\nimport pickle\nwarnings.filterwarnings('ignore')\n\n# Machine learning\nfrom sklearn.model_selection import train_test_split, cross_val_score, StratifiedKFold, TimeSeriesSplit\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier\nfrom sklearn.preprocessing import StandardScaler, RobustScaler\nfrom sklearn.metrics import (\n    classification_report, confusion_matrix, roc_curve, auc,\n    precision_recall_curve, accuracy_score, cohen_kappa_score,\n    f1_score, precision_score, recall_score\n)\nfrom sklearn.feature_selection import mutual_info_classif, SelectKBest\n\n# Enhanced feature selection (Transue methodology)\ntry:\n    from boruta import BorutaPy\n    BORUTA_AVAILABLE = True\n    print(\"\u2705 Boruta package available - enhanced feature selection enabled\")\nexcept ImportError:\n    BORUTA_AVAILABLE = False\n    print(\"\u26a0\ufe0f Boruta package not available - install with: pip install boruta\")\n    print(\"   Falling back to mutual information + random forest importance only\")\n\n# Statistical analysis and post-hoc testing\nfrom scipy import stats\nfrom scipy.stats import spearmanr, pearsonr\ntry:\n    from scipy.stats import tukey_hsd\n    POSTHOC_AVAILABLE = True\n    print(\"\u2705 Post-hoc testing available\")\nexcept ImportError:\n    POSTHOC_AVAILABLE = False\n    print(\"\u26a0\ufe0f Advanced post-hoc testing not available - using basic statistical tests\")\n\n# Set plotting style\nplt.style.use('default')\nsns.set_palette(\"husl\")\n\n# Find project root by looking for the data folder\ncurrent_dir = Path(__file__).parent if \"__file__\" in locals() else Path.cwd()\nproject_root = current_dir\nwhile not (project_root / \"data\").exists() and project_root != project_root.parent:\n    project_root = project_root.parent\n\n# Data directories\nDATA_ROOT = project_root / \"data\"\ndata_dir = DATA_ROOT / \"processed\"\nplot_dir = DATA_ROOT.parent / \"dashboard/public/views/notebooks\"\nplot_dir.mkdir(exist_ok=True, parents=True)\n\nprint(\"Libraries loaded successfully\")\nprint(f\"Data root: {DATA_ROOT}\")\nprint(f\"Plot directory: {plot_dir}\")", "code_hash": "027743bc29991607e2ec7921d858ce5a", "config": {"column": null, "disabled": false, "hide_code": true}, "id": "MJUe", "name": "_"}, {"code": "mo.md(\n    r\"\"\"\n## Data Loading and Preparation\n\nLoading all processed datasets and preparing them for enhanced community-level analysis.\n\"\"\"\n)", "code_hash": "49f453afcb44f02d2944da9bb20d8910", "config": {"column": null, "disabled": false, "hide_code": true}, "id": "vblA", "name": "_"}, {"code": "# Load all processed datasets (same as original)\nprint(\"Loading processed datasets...\")\n\n# Load reduced acoustic indices from Notebook 3\ndf_indices = pd.read_parquet(DATA_ROOT / \"processed/03_reduced_acoustic_indices.parquet\")\n\n# Load aligned detections (original fish-only data)\ndf_detections = pd.read_parquet(DATA_ROOT / \"processed/02_detections_aligned_2021.parquet\")\n\n# Load enhanced marine community data (fish + dolphins from notebook 08)\nmarine_community_file = DATA_ROOT / \"processed/02_detections_with_marine_community.parquet\"\nif marine_community_file.exists():\n    df_marine_community = pd.read_parquet(marine_community_file)\n    print(f\"\u2705 Loaded enhanced marine community data: {df_marine_community.shape}\")\nelse:\n    print(f\"\u26a0\ufe0f Marine community data not found: {marine_community_file}\")\n    print(\"Run notebook 08 first to generate marine community metrics\")\n    df_marine_community = None\n\n# Load environmental data\ndf_env = pd.read_parquet(DATA_ROOT / \"processed/02_environmental_aligned_2021.parquet\")\n\n# Load temporal features\ndf_temporal = pd.read_parquet(DATA_ROOT / \"processed/02_temporal_features_2021.parquet\")\n\n# Load detection metadata to identify fish species\ndf_det_metadata = pd.read_parquet(DATA_ROOT / \"processed/metadata/01_detection_columns.parquet\")\n\nprint(f\"Indices shape: {df_indices.shape}\")\nprint(f\"Detections shape: {df_detections.shape}\")\nprint(f\"Environmental shape: {df_env.shape}\") \nprint(f\"Temporal features shape: {df_temporal.shape}\")", "code_hash": "451d020d4b2dc74786817904d45ac98b", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "bkHC", "name": "_"}, {"code": "# Get fish species columns\nfish_species = df_det_metadata[\n    (df_det_metadata['group'] == 'fish') &\n    (df_det_metadata['keep_species'] == 1)\n]['long_name'].tolist()\n\n# Get acoustic index columns (exclude metadata)\nindex_cols = [col for col in df_indices.columns\n              if col not in ['datetime', 'station', 'year']]\n\n# Merge all datasets\ndf_master = df_indices.merge(\n    df_detections[['datetime', 'station', 'year'] + fish_species],\n    on=['datetime', 'station', 'year'],\n    how='left'\n)\n\ndf_master = df_master.merge(\n    df_env[['datetime', 'station', 'year', 'Water temp (\u00b0C)', 'Water depth (m)',\n            'Broadband (1-40000 Hz)', 'Low (50-1200 Hz)', 'High (7000-40000 Hz)']],\n    on=['datetime', 'station', 'year'],\n    how='left'\n)\n\ndf_master = df_master.merge(\n    df_temporal[['datetime', 'station', 'year', 'hour', 'month', 'season', 'time_period']],\n    on=['datetime', 'station', 'year'],\n    how='left'\n)\n\n# Rename time_period to diel_period for consistency\ndf_master = df_master.rename(columns={'time_period': 'diel_period'})\n\nprint(f\"Master dataset shape: {df_master.shape}\")\nprint(f\"Fish species columns ({len(fish_species)}): {fish_species}\")\nprint(f\"Acoustic index columns ({len(index_cols)}): {index_cols[:5]}...\")", "code_hash": "ad9f6a7acd370fb70c7b9945606c4ec2", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "lEQa", "name": "_"}, {"code": "mo.md(\n    r\"\"\"\n## Community Activity Metrics Creation\n\nCreating aggregate community-level metrics that move beyond species-specific analysis.\n\n## Strategy: From Species-Specific to Community-Level Analysis\n\nInstead of trying to predict individual species calling patterns, we aggregate across all species to ask: \n**\"Is there biological activity happening?\"** This approach:\n\n1. **Reduces complexity**: 7 species \u00d7 4 intensity levels = 28 possible states \u2192 4 binary questions\n2. **Increases signal**: Combines weak species-specific signals into stronger community signal  \n3. **Matches practical needs**: Often we care more about \"when to listen carefully\" than \"exactly which species\"\n4. **Improves statistical power**: More balanced classes, clearer patterns\n\"\"\"\n)", "code_hash": "c616b351a860a0a50d250256557453b5", "config": {"column": null, "disabled": false, "hide_code": true}, "id": "PKri", "name": "_"}, {"code": "# Create community-level activity metrics (same as original)\nprint(\"Creating community activity metrics...\")\nprint(f\"Working with {len(fish_species)} fish species: {fish_species}\")\n\n# Create community metrics\ndf_community = df_master.copy()\ndf_community['total_fish_activity'] = df_community[fish_species].sum(axis=1)\ndf_community['num_active_species'] = (df_community[fish_species] > 0).sum(axis=1)\ndf_community['max_species_activity'] = df_community[fish_species].max(axis=1)\ndf_community['activity_diversity'] = df_community[fish_species].std(axis=1) / (df_community[fish_species].mean(axis=1) + 0.01)\n\n# Binary classification targets\ntotal_activity_75th = df_community['total_fish_activity'].quantile(0.75)\ntotal_activity_90th = df_community['total_fish_activity'].quantile(0.90)\n\ndf_community['high_activity_75th'] = (df_community['total_fish_activity'] >= total_activity_75th).astype(int)\ndf_community['high_activity_90th'] = (df_community['total_fish_activity'] >= total_activity_90th).astype(int)\ndf_community['any_activity'] = (df_community['total_fish_activity'] > 0).astype(int)\ndf_community['multi_species_active'] = (df_community['num_active_species'] >= 2).astype(int)\n\nprint(f\"Fish community metrics created. Sample statistics:\")\nprint(f\"Total activity - Mean: {df_community['total_fish_activity'].mean():.2f}\")\nprint(f\"High activity (75th): {df_community['high_activity_75th'].mean():.1%}\")\nprint(f\"Any activity: {df_community['any_activity'].mean():.1%}\")", "code_hash": "e834eb354ab16d4bd9cf76e0ca3174b2", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "Xref", "name": "_"}, {"code": "mo.md(\n    r\"\"\"\n## Enhanced Feature Selection: Comparative Analysis\n\nThis section implements both traditional and state-of-the-art feature selection approaches to identify the most important acoustic indices for biological screening.\n\n## Methodological Comparison\n\n### Approach 1: Mutual Information (Original Method)\n**What it does**: Measures how much information one variable provides about another, capturing both linear and non-linear relationships.\n\n**Biological relevance**: \n- Can detect threshold effects (e.g., fish only call when certain acoustic conditions are met)\n- Captures complex interaction patterns between indices and biology\n- Good for discovering unexpected acoustic-biological relationships\n\n### Approach 2: Boruta + Random Forest (Transue et al. 2023)\n**What it does**: Uses an ensemble of decision trees to systematically identify all statistically relevant features.\n\n**Biological relevance**:\n- Established methodology in marine bioacoustics research\n- Handles feature interactions naturally through tree-based decisions\n- Provides consistent, interpretable feature rankings\n- Proven approach for acoustic data with temporal autocorrelation\n\n## Why Compare Both?\n\n**Scientific validation**: If both methods identify the same indices as important, we have strong evidence for their biological relevance.\n\n**Methodological robustness**: Shows our findings aren't dependent on a single analytical approach.\n\n**Best of both worlds**: Combines novel discovery potential (MI) with established field methodology (Boruta).\n\"\"\"\n)", "code_hash": "6f4f11e1d9d3a4cd102d15d039008941", "config": {"column": null, "disabled": false, "hide_code": true}, "id": "SFPL", "name": "_"}, {"code": "# Enhanced Feature Selection: Comparative Analysis\nprint(\"ENHANCED FEATURE SELECTION: COMPARATIVE ANALYSIS\")\nprint(\"=\"*70)\nprint(\"Implementing both Mutual Information and Boruta approaches\")\nprint(\"=\"*70)\n\n# Prepare feature matrix\nmodeling_cols = index_cols + ['Water temp (\u00b0C)', 'Water depth (m)', 'hour', 'month']\ntarget_cols = ['high_activity_75th', 'high_activity_90th', 'any_activity', 'multi_species_active']\n\nprint(f\"Feature categories:\")\nprint(f\"  - Acoustic indices: {len(index_cols)} variables\")\nprint(f\"  - Environmental: 2 variables (temperature, depth)\")\nprint(f\"  - Temporal: 2 variables (hour, month)\")\nprint(f\"  - Total features: {len(modeling_cols)}\")\n\n# Prepare modeling dataset\ndf_modeling = df_community[modeling_cols + target_cols].dropna()\nprint(f\"Modeling dataset: {df_modeling.shape[0]:,} complete samples\")\n\n# Standardize features\nX_features = df_modeling[modeling_cols]\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X_features)\n\n# Initialize results storage\ncomparative_feature_results = {}\n\n# =====================================================================\n# COMPARATIVE FEATURE SELECTION FOR EACH TARGET\n# =====================================================================\n\nfor current_target_name in target_cols:\n    print(f\"\\n\" + \"=\"*50)\n    print(f\"ANALYZING TARGET: {current_target_name}\")\n    print(\"=\"*50)\n\n    y_target = df_modeling[current_target_name]\n\n    # Check class balance\n    class_balance = y_target.value_counts(normalize=True)\n    print(f\"Class balance: {class_balance.to_dict()}\")\n\n    if y_target.std() == 0:\n        print(f\"Skipping {current_target_name} - no variance in target\")\n        continue\n\n    current_target_results = {\n        'target_name': current_target_name,\n        'class_balance': class_balance.to_dict(),\n        'sample_size': len(y_target)\n    }\n\n    # -------------------------------------------------------------\n    # METHOD 1: MUTUAL INFORMATION ANALYSIS\n    # -------------------------------------------------------------\n    print(f\"\\n1. MUTUAL INFORMATION FEATURE SELECTION\")\n    print(\"-\" * 45)\n\n    # Calculate mutual information scores\n    mi_scores = mutual_info_classif(X_scaled, y_target, random_state=42)\n\n    # Create MI results dataframe\n    mi_results = pd.DataFrame({\n        'feature': modeling_cols,\n        'mi_score': mi_scores,\n        'feature_type': ['acoustic_index' if col in index_cols else \n                       'environmental' if col in ['Water temp (\u00b0C)', 'Water depth (m)'] else \n                       'temporal' for col in modeling_cols]\n    }).sort_values('mi_score', ascending=False)\n\n    print(f\"Top 5 features by Mutual Information:\")\n    for i, (_, row) in enumerate(mi_results.head().iterrows()):\n        print(f\"  {i+1}. {row['feature']} ({row['feature_type']}): {row['mi_score']:.3f}\")\n\n    current_target_results['mutual_information'] = {\n        'rankings': mi_results,\n        'top_5_features': mi_results.head()['feature'].tolist(),\n        'best_acoustic_index': mi_results[mi_results['feature_type'] == 'acoustic_index'].iloc[0]['feature'],\n        'best_mi_score': mi_results.iloc[0]['mi_score']\n    }\n\n    # -------------------------------------------------------------\n    # METHOD 2: BORUTA FEATURE SELECTION (if available)\n    # -------------------------------------------------------------\n    if BORUTA_AVAILABLE:\n        print(f\"\\n2. BORUTA + RANDOM FOREST FEATURE SELECTION\")\n        print(\"-\" * 50)\n        print(\"Following Transue et al. (2023) methodology...\")\n\n        # Initialize Random Forest for Boruta (matching Transue parameters)\n        rf_selector = RandomForestClassifier(\n            n_estimators=100, \n            max_depth=8,\n            random_state=42,\n            n_jobs=-1  # Use all cores for faster processing\n        )\n\n        # Initialize Boruta\n        boruta_selector = BorutaPy(\n            rf_selector,\n            n_estimators='auto',\n            verbose=0,  # Reduce output\n            random_state=42,\n            max_iter=100  # Limit iterations to prevent long runtime\n        )\n\n        try:\n            # Fit Boruta\n            print(\"Running Boruta feature selection (this may take a moment)...\")\n            boruta_selector.fit(X_scaled, y_target)\n\n            # Extract results\n            selected_features = np.array(modeling_cols)[boruta_selector.support_]\n            tentative_features = np.array(modeling_cols)[boruta_selector.support_weak_]\n            rejected_features = np.array(modeling_cols)[~boruta_selector.support_ & ~boruta_selector.support_weak_]\n\n            # Create Boruta results dataframe\n            boruta_results = pd.DataFrame({\n                'feature': modeling_cols,\n                'boruta_ranking': boruta_selector.ranking_,\n                'boruta_decision': ['confirmed' if boruta_selector.support_[i] else \n                                   'tentative' if boruta_selector.support_weak_[i] else \n                                   'rejected' for i in range(len(modeling_cols))],\n                'feature_type': ['acoustic_index' if col in index_cols else \n                               'environmental' if col in ['Water temp (\u00b0C)', 'Water depth (m)'] else \n                               'temporal' for col in modeling_cols]\n            }).sort_values('boruta_ranking')\n\n            print(f\"Boruta Results:\")\n            print(f\"  \u2705 Confirmed features: {len(selected_features)} ({list(selected_features)})\")\n            print(f\"  \u2753 Tentative features: {len(tentative_features)} ({list(tentative_features)})\")\n            print(f\"  \u274c Rejected features: {len(rejected_features)}\")\n\n            # Get Random Forest feature importance from the final model\n            rf_final = RandomForestClassifier(n_estimators=100, max_depth=8, random_state=42)\n            rf_final.fit(X_scaled, y_target)\n            rf_importance = rf_final.feature_importances_\n\n            boruta_results['rf_importance'] = rf_importance\n\n            current_target_results['boruta'] = {\n                'rankings': boruta_results,\n                'confirmed_features': list(selected_features),\n                'tentative_features': list(tentative_features),\n                'rejected_features': list(rejected_features),\n                'n_confirmed': len(selected_features),\n                'best_acoustic_index': boruta_results[\n                    (boruta_results['feature_type'] == 'acoustic_index') &\n                    (boruta_results['boruta_decision'] == 'confirmed')\n                ]['feature'].iloc[0] if len(selected_features) > 0 else None\n            }\n\n\n\n            print(f\"Top confirmed features by ranking:\")\n            confirmed_features = boruta_results[boruta_results['boruta_decision'] == 'confirmed'].head()\n            for i, (_, row) in enumerate(confirmed_features.iterrows()):\n                print(f\"  {i+1}. {row['feature']} ({row['feature_type']}): rank {row['boruta_ranking']}\")\n\n        except Exception as e:\n            print(f\"\u26a0\ufe0f Boruta analysis failed for {current_target_name}: {str(e)}\")\n            print(\"Falling back to Random Forest importance only...\")\n\n            # Fallback to RF importance\n            rf_fallback = RandomForestClassifier(n_estimators=100, max_depth=8, random_state=42)\n            rf_fallback.fit(X_scaled, y_target)\n            rf_importance = rf_fallback.feature_importances_\n\n            rf_results_df = pd.DataFrame({\n                'feature': modeling_cols,\n                'rf_importance': rf_importance,\n                'feature_type': ['acoustic_index' if col in index_cols else \n                               'environmental' if col in ['Water temp (\u00b0C)', 'Water depth (m)'] else \n                               'temporal' for col in modeling_cols]\n            }).sort_values('rf_importance', ascending=False)\n\n            current_target_results['boruta'] = {\n                'rankings': rf_results_df,\n                'confirmed_features': rf_results_df.head(5)['feature'].tolist(),\n                'fallback_used': True,\n                'best_acoustic_index': rf_results[rf_results['feature_type'] == 'acoustic_index'].iloc[0]['feature']\n            }\n\n    else:\n        print(f\"\\n2. BORUTA NOT AVAILABLE - USING RANDOM FOREST IMPORTANCE\")\n        print(\"-\" * 55)\n\n        # Fallback to RF importance\n        rf_fallback = RandomForestClassifier(n_estimators=100, max_depth=8, random_state=42)\n        rf_fallback.fit(X_scaled, y_target)\n        rf_importance = rf_fallback.feature_importances_\n\n        rf_results_df = pd.DataFrame({\n            'feature': modeling_cols,\n            'rf_importance': rf_importance,\n            'feature_type': ['acoustic_index' if col in index_cols else \n                           'environmental' if col in ['Water temp (\u00b0C)', 'Water depth (m)'] else \n                           'temporal' for col in modeling_cols]\n        }).sort_values('rf_importance', ascending=False)\n\n        print(f\"Top 5 features by Random Forest importance:\")\n        for i, (_, row) in enumerate(rf_results_df.head().iterrows()):\n            print(f\"  {i+1}. {row['feature']} ({row['feature_type']}): {row['rf_importance']:.3f}\")\n            print(f\"  {_i+1}. {rf_row['feature']} ({rf_row['feature_type']}): {rf_row['rf_importance']:.3f}\")\n\n        current_target_results['boruta'] = {\n            'rankings': rf_results_df,\n            'confirmed_features': rf_results_df.head(5)['feature'].tolist(),\n            'fallback_used': True,\n            'best_acoustic_index': rf_results[rf_results['feature_type'] == 'acoustic_index'].iloc[0]['feature']\n        }\n\n    # -------------------------------------------------------------\n    # METHOD COMPARISON AND CONSENSUS\n    # -------------------------------------------------------------\n    print(f\"\\n3. COMPARATIVE ANALYSIS: MI vs BORUTA\")\n    print(\"-\" * 40)\n\n    mi_top_5 = set(current_target_results['mutual_information']['top_5_features'])\n    boruta_top_5 = set(current_target_results['boruta']['confirmed_features'][:5])\n\n    _consensus_features = mi_top_5.intersection(boruta_top_5)\n    mi_unique = mi_top_5 - boruta_top_5\n    boruta_unique = boruta_top_5 - mi_top_5\n\n    print(f\"Feature agreement analysis:\")\n    print(f\"  \ud83e\udd1d Consensus features (both methods): {len(_consensus_features)}\")\n    if _consensus_features:\n        print(f\"      {list(_consensus_features)}\")\n    print(f\"  \ud83d\udd0d MI-unique features: {len(mi_unique)}\")\n    if mi_unique:\n        print(f\"      {list(mi_unique)}\")\n    print(f\"  \ud83c\udf32 Boruta-unique features: {len(boruta_unique)}\")\n    if boruta_unique:\n        print(f\"      {list(boruta_unique)}\")\n\n    current_target_results['comparison'] = {\n        'consensus_features': list(_consensus_features),\n        'mi_unique_features': list(mi_unique),\n        'boruta_unique_features': list(boruta_unique),\n        'agreement_rate': len(_consensus_features) / 5.0,\n        'total_unique_features': len(mi_top_5.union(boruta_top_5))\n    }\n\n    comparative_feature_results[current_target_name] = current_target_results\n\nprint(f\"\\n\" + \"=\"*70)\nprint(\"COMPARATIVE FEATURE SELECTION COMPLETE\")\nprint(\"=\"*70)\nprint(f\"Analyzed {len(comparative_feature_results)} targets successfully\")", "code_hash": "db9ed82d8ce60c95c3b9fc804e270a09", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "BYtC", "name": "_"}, {"code": "mo.md(\n    r\"\"\"\n## Enhanced Model Development with Transue Methodology\n\nTraining machine learning models using the enhanced feature selection results, with emphasis on Random Forest modeling following Transue et al. (2023).\n\n## Model Selection Strategy\n\n**Primary Focus: Random Forest** (following Transue et al.)\n- Proven methodology for marine bioacoustic data\n- Handles temporal autocorrelation naturally\n- Provides interpretable feature importance\n- Robust to outliers and missing data\n\n**Comparative Models** (for validation):\n- Logistic Regression: Linear baseline\n- Decision Tree: Simple interpretable rules\n\n## Enhanced Validation Framework\n\nFollowing Transue et al. (2023):\n- **Out-of-bag error estimation** (built into Random Forest)\n- **Stratified cross-validation** for robust performance estimates  \n- **Feature importance ranking** with statistical significance\n- **Model performance on both consensus and method-specific features**\n\"\"\"\n)", "code_hash": "180509900f132d01efc2695e34ce562f", "config": {"column": null, "disabled": false, "hide_code": true}, "id": "RGSE", "name": "_"}, {"code": "# Enhanced Model Development\nprint(\"ENHANCED MODEL DEVELOPMENT WITH TRANSUE METHODOLOGY\")\nprint(\"=\"*70)\nprint(\"Primary focus: Random Forest with comparative validation\")\nprint(\"=\"*70)\n\n# Model configurations (emphasizing Random Forest following Transue et al.)\nenhanced_models = {\n    'Random Forest (Primary)': RandomForestClassifier(\n        n_estimators=100,      # Match Transue parameters\n        max_depth=8,           # Prevent overfitting\n        min_samples_leaf=5,    # Ensure robust nodes\n        oob_score=True,        # Enable out-of-bag scoring (Transue method)\n        random_state=42,\n        n_jobs=-1              # Use all cores\n    ),\n    'Random Forest (Consensus)': RandomForestClassifier(  # Will use consensus features only\n        n_estimators=100,\n        max_depth=8,\n        min_samples_leaf=5,\n        oob_score=True,\n        random_state=42,\n        n_jobs=-1\n    ),\n    'Logistic Regression': LogisticRegression(max_iter=1000, random_state=42),\n    'Decision Tree': DecisionTreeClassifier(\n        max_depth=8,\n        min_samples_leaf=10,\n        random_state=42\n    ),\n}\n\nprint(f\"Model configurations: {list(enhanced_models.keys())}\")\n\n# Initialize enhanced results storage\nenhanced_model_results = {}\nfeature_performance_comparison = {}\n\nfor _target_name in target_cols:\n    if _target_name not in comparative_feature_results:\n        continue\n\n    print(f\"\\n\" + \"=\"*60)\n    print(f\"TRAINING ENHANCED MODELS FOR: {_target_name}\")\n    print(\"=\"*60)\n\n    _y_target = df_modeling[_target_name]\n    target_feature_results = comparative_feature_results[_target_name]\n\n    # Get different feature sets for comparison\n    all_features = modeling_cols\n    _consensus_features = target_feature_results['comparison']['consensus_features']\n    mi_top_features = target_feature_results['mutual_information']['top_5_features']\n    boruta_top_features = target_feature_results['boruta']['confirmed_features'][:5]\n\n    print(f\"Feature set comparison:\")\n    print(f\"  All features: {len(all_features)}\")\n    print(f\"  Consensus features: {len(_consensus_features)}\")\n    print(f\"  MI top features: {len(mi_top_features)}\")\n    print(f\"  Boruta top features: {len(boruta_top_features)}\")\n\n    target_model_results = {}\n\n    # Test different feature sets\n    feature_sets = {\n        'All Features': all_features,\n        'Consensus Features': _consensus_features if len(_consensus_features) >= 3 else all_features,\n        'MI Top Features': mi_top_features,\n        'Boruta Top Features': boruta_top_features\n    }\n\n    for feature_set_name, feature_list in feature_sets.items():\n        print(f\"\\n--- FEATURE SET: {feature_set_name} ({len(feature_list)} features) ---\")\n\n        if len(feature_list) < 3:\n            print(f\"Skipping {feature_set_name} - insufficient features ({len(feature_list)})\")\n            continue\n\n        # Prepare features\n        _X_features = df_modeling[feature_list]\n        scaler_set = StandardScaler()\n        X_scaled_set = scaler_set.fit_transform(_X_features)\n\n        feature_set_results = {}\n\n        # Train models on this feature set\n        for model_name, model in enhanced_models.items():\n            # Skip consensus model if not using consensus features\n            if model_name == 'Random Forest (Consensus)' and feature_set_name != 'Consensus Features':\n                continue\n            # Skip primary model if using consensus features (avoid duplication)\n            if model_name == 'Random Forest (Primary)' and feature_set_name == 'Consensus Features':\n                continue\n\n            # Create fresh model instance\n            model_instance = type(model)(**model.get_params())\n\n            # Split data\n            X_train, X_test, y_train, y_test = train_test_split(\n                X_scaled_set, _y_target, test_size=0.3, random_state=42, stratify=_y_target\n            )\n\n            # Train model\n            model_instance.fit(X_train, y_train)\n\n            # Predictions\n            y_pred = model_instance.predict(X_test)\n            y_prob = model_instance.predict_proba(X_test)[:, 1] if hasattr(model_instance, 'predict_proba') else y_pred\n\n            # Calculate metrics\n            accuracy = accuracy_score(y_test, y_pred)\n            precision = precision_score(y_test, y_pred, average='binary', zero_division=0)\n            recall = recall_score(y_test, y_pred, average='binary', zero_division=0)\n            f1 = f1_score(y_test, y_pred, average='binary', zero_division=0)\n            kappa = cohen_kappa_score(y_test, y_pred)\n\n            # Cross-validation\n            cv_model = type(model)(**model.get_params())\n            cv_scores = cross_val_score(cv_model, X_scaled_set, _y_target, cv=StratifiedKFold(5), scoring='f1')\n\n            # Out-of-bag score for Random Forest (Transue methodology)\n            oob_score = None\n            if hasattr(model_instance, 'oob_score_'):\n                oob_score = model_instance.oob_score_\n\n            model_results = {\n                'model': model_instance,\n                'feature_set': feature_set_name,\n                'feature_list': feature_list,\n                'n_features': len(feature_list),\n                'accuracy': accuracy,\n                'precision': precision,\n                'recall': recall,\n                'f1': f1,\n                'kappa': kappa,\n                'cv_f1_mean': cv_scores.mean(),\n                'cv_f1_std': cv_scores.std(),\n                'oob_score': oob_score,\n                'y_test': y_test,\n                'y_pred': y_pred,\n                'y_prob': y_prob\n            }\n\n            feature_set_results[model_name] = model_results\n\n            # Print performance\n            performance_str = f\"F1={f1:.3f}, Precision={precision:.3f}, Recall={recall:.3f}\"\n            if oob_score:\n                performance_str += f\", OOB={oob_score:.3f}\"\n            print(f\"    {model_name}: {performance_str}\")\n\n        target_model_results[feature_set_name] = feature_set_results\n\n    enhanced_model_results[_target_name] = target_model_results\n\n    # Identify best performing models for this target\n    print(f\"\\n\ud83c\udfc6 BEST MODELS FOR {_target_name}:\")\n    _best_f1 = 0\n    best_model_info = None\n\n    for feature_set_name, _models in target_model_results.items():\n        for _model_name, _results in _models.items():\n            if _results['f1'] > _best_f1:\n                _best_f1 = _results['f1']\n                best_model_info = (feature_set_name, _model_name, _results)\n\n    if best_model_info:\n        _feature_set, _model_name, _results = best_model_info\n        print(f\"    {_model_name} with {_feature_set}\")\n        print(f\"    F1: {_results['f1']:.3f}, Features: {_results['n_features']}\")\n\nprint(f\"\\n\" + \"=\"*70)\nprint(\"ENHANCED MODEL DEVELOPMENT COMPLETE\")\nprint(\"=\"*70)", "code_hash": "98e06a431f10ffb68cb55f1dd8774516", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "Kclp", "name": "_"}, {"code": "mo.md(\n    r\"\"\"\n## Enhanced Results Analysis and Visualization\n\nComprehensive analysis of feature selection and model performance, comparing traditional and Transue methodologies.\n\"\"\"\n)", "code_hash": "9f3f64c6bfc055dd95f3af1c20465f3d", "config": {"column": null, "disabled": false, "hide_code": true}, "id": "emfo", "name": "_"}, {"code": "# Enhanced Results Analysis and Visualization\nprint(\"ENHANCED RESULTS ANALYSIS\")\nprint(\"=\"*50)\n\n# 1. Feature Selection Comparison Visualization\nfig, axes = plt.subplots(2, 2, figsize=(15, 12))\n\ntarget_names_viz = list(comparative_feature_results.keys())[:4]  # Max 4 for visualization\n\nfor _i_viz, target_name_viz in enumerate(target_names_viz):\n    if _i_viz >= 4:\n        break\n\n    ax = axes[_i_viz//2, _i_viz%2]\n    target_results_comp = comparative_feature_results[target_name_viz]\n\n    # Get top features from both methods\n    mi_features = target_results_comp['mutual_information']['rankings'].head(8)\n\n    # Plot MI scores\n    y_pos = np.arange(len(mi_features))\n    bars = ax.barh(y_pos, mi_features['mi_score'], alpha=0.7)\n\n    # Color bars by feature type\n    colors = {'acoustic_index': 'steelblue', 'environmental': 'orange', 'temporal': 'green'}\n    for j, (_, mi_row) in enumerate(mi_features.iterrows()):\n        bars[j].set_color(colors.get(mi_row['feature_type'], 'gray'))\n\n    ax.set_yticks(y_pos)\n    ax.set_yticklabels(mi_features['feature'], fontsize=8)\n    ax.set_xlabel('Mutual Information Score')\n    ax.set_title(f'{target_name.replace(\"_\", \" \").title()}\\nFeature Importance')\n    ax.grid(True, alpha=0.3, axis='x')\n    ax.invert_yaxis()\n\n# Add legend\nhandles = [plt.Rectangle((0,0),1,1, color=colors[key]) for key in colors.keys()]\nlabels = ['Acoustic Index', 'Environmental', 'Temporal']\nfig.legend(handles, labels, loc='upper right', bbox_to_anchor=(1, 1))\n\nplt.tight_layout()\nplt.savefig(plot_dir / '06_01_enhanced_feature_importance.png', dpi=150, bbox_inches='tight')\nplt.show()\n\n# 2. Model Performance Comparison\nperformance_summary = []\n\nfor _target_name, _target_results in enhanced_model_results.items():\n    for _feature_set, _models in _target_results.items():\n        for _model_name, _results in _models.items():\n            performance_summary.append({\n                'target': _target_name,\n                'feature_set': _feature_set,\n                'model': _model_name,\n                'f1': _results['f1'],\n                'precision': _results['precision'],\n                'recall': _results['recall'],\n                'n_features': _results['n_features'],\n                'cv_f1_mean': _results['cv_f1_mean']\n            })\n\nperformance_df = pd.DataFrame(performance_summary)\n\nif len(performance_df) > 0:\n    print(f\"\\nPerformance Summary:\")\n    print(performance_df.groupby(['model', 'feature_set']).agg({\n        'f1': ['mean', 'std'],\n        'n_features': 'mean'\n    }).round(3))\n\n    # Best performance by model type\n    print(f\"\\nBest Performance by Model Type:\")\n    best_by_model = performance_df.groupby('model')['f1'].max().sort_values(ascending=False)\n    for _model_name, _best_f1 in best_by_model.items():\n        print(f\"  {_model_name}: {_best_f1:.3f}\")\n\n# 3. Feature Set Performance Comparison\nif len(performance_df) > 0:\n    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 6))\n\n    # Performance by feature set\n    feature_performance = performance_df.groupby('feature_set')['f1'].agg(['mean', 'std']).sort_values('mean', ascending=False)\n\n    ax1.bar(range(len(feature_performance)), feature_performance['mean'], \n            yerr=feature_performance['std'], alpha=0.7, capsize=5)\n    ax1.set_xticks(range(len(feature_performance)))\n    ax1.set_xticklabels(feature_performance.index, rotation=45, ha='right')\n    ax1.set_ylabel('Mean F1 Score')\n    ax1.set_title('Performance by Feature Set')\n    ax1.grid(True, alpha=0.3, axis='y')\n\n    # Feature count vs performance\n    ax2.scatter(performance_df['n_features'], performance_df['f1'], alpha=0.6, s=60)\n    ax2.set_xlabel('Number of Features')\n    ax2.set_ylabel('F1 Score')\n    ax2.set_title('Performance vs Feature Count')\n    ax2.grid(True, alpha=0.3)\n\n    plt.tight_layout()\n    plt.savefig(plot_dir / '06_01_enhanced_performance_comparison.png', dpi=150, bbox_inches='tight')\n    plt.show()\n\nprint(f\"Enhanced visualizations saved to {plot_dir}\")", "code_hash": "b13682ee689303ed8be4c3b5fcd845c1", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "Hstk", "name": "_"}, {"code": "mo.md(\n    r\"\"\"\n## Comprehensive Results Summary and Scientific Interpretation\n\nSynthesizing findings from the enhanced comparative analysis to provide actionable insights for biological screening.\n\"\"\"\n)", "code_hash": "4d81c06c5ff91bc699602b80da971a7b", "config": {"column": null, "disabled": false, "hide_code": true}, "id": "nWHF", "name": "_"}, {"code": "# Comprehensive Results Summary\nprint(\"COMPREHENSIVE RESULTS SUMMARY AND SCIENTIFIC INTERPRETATION\")\nprint(\"=\"*80)\n\n# Save enhanced results\nprint(\"Saving enhanced analysis results...\")\n\n# Save comparative feature results\nwith open(DATA_ROOT / \"processed/06_01_comparative_feature_results.pkl\", 'wb') as f:\n    pickle.dump(comparative_feature_results, f)\n\n# Save enhanced model results\nwith open(DATA_ROOT / \"processed/06_01_enhanced_model_results.pkl\", 'wb') as f:\n    pickle.dump(enhanced_model_results, f)\n\n# Create comprehensive summary\nsummary = {\n    'methodology': {\n        'boruta_available': BORUTA_AVAILABLE,\n        'approaches_compared': ['mutual_information', 'boruta_random_forest'],\n        'models_tested': ['Random Forest (Primary)', 'Logistic Regression', 'Decision Tree'],\n        'feature_sets_tested': ['All Features', 'Consensus Features', 'MI Top Features', 'Boruta Top Features']\n    },\n    'feature_selection_insights': {},\n    'model_performance': {},\n    'scientific_conclusions': {}\n}\n\n# Analyze feature selection insights\nprint(\"\\n1. FEATURE SELECTION INSIGHTS\")\nprint(\"=\"*40)\n\nconsensus_summary = {}\nfor summary_target_name, consensus_results in comparative_feature_results.items():\n    comparison = consensus_results['comparison']\n    consensus_rate = comparison['agreement_rate']\n\n    consensus_summary[target_name] = {\n        'agreement_rate': consensus_rate,\n        'consensus_features': comparison['consensus_features'],\n        'total_unique_features': comparison['total_unique_features']\n    }\n\n    print(f\"\\n{summary_target_name}:\")\n    print(f\"  Agreement rate: {consensus_rate:.1%}\")\n    print(f\"  Consensus features: {comparison['consensus_features']}\")\n\nsummary['feature_selection_insights'] = consensus_summary\n\n# Analyze model performance\nprint(f\"\\n2. MODEL PERFORMANCE ANALYSIS\")\nprint(\"=\"*35)\n\nif len(performance_df) > 0:\n    # Best overall performance\n    best_overall = performance_df.loc[performance_df['f1'].idxmax()]\n    print(f\"\\nBest Overall Performance:\")\n    print(f\"  Model: {best_overall['model']}\")\n    print(f\"  Feature Set: {best_overall['feature_set']}\")\n    print(f\"  Target: {best_overall['target']}\")\n    print(f\"  F1 Score: {best_overall['f1']:.3f}\")\n    print(f\"  Features Used: {best_overall['n_features']}\")\n\n    # Random Forest performance (Transue methodology focus)\n    performance_rf_results = performance_df[performance_df['model'].str.contains('Random Forest')]\n    if len(performance_rf_results) > 0:\n        rf_mean_performance = performance_rf_results.groupby('feature_set')['f1'].mean()\n        print(f\"\\nRandom Forest Performance by Feature Set:\")\n        for feature_set, mean_f1 in rf_mean_performance.sort_values(ascending=False).items():\n            print(f\"  {feature_set}: {mean_f1:.3f}\")\n\n    # Feature set effectiveness\n    feature_set_performance = performance_df.groupby('feature_set')['f1'].agg(['mean', 'count']).sort_values('mean', ascending=False)\n    print(f\"\\nFeature Set Effectiveness:\")\n    for _feature_set, (mean_f1, count) in feature_set_performance.iterrows():\n        print(f\"  {_feature_set}: {mean_f1:.3f} (n={count})\")\n\n    summary['model_performance'] = {\n        'best_overall': {\n            'model': best_overall['model'],\n            'feature_set': best_overall['feature_set'],\n            'target': best_overall['target'],\n            'f1_score': float(best_overall['f1']),\n            'n_features': int(best_overall['n_features'])\n        },\n        'random_forest_by_features': {k: float(v) for k, v in rf_mean_performance.items()},\n        'feature_set_rankings': {k: float(v['mean']) for k, v in feature_set_performance.iterrows()}\n    }\n\n# Scientific conclusions\nprint(f\"\\n3. SCIENTIFIC CONCLUSIONS\")\nprint(\"=\"*30)\n\nconclusions = []\n\n# Methodology comparison conclusion\nif BORUTA_AVAILABLE:\n    avg_consensus_rate = np.mean([res['agreement_rate'] for res in consensus_summary.values()])\n    if avg_consensus_rate > 0.6:\n        conclusions.append(f\"\u2705 High agreement between MI and Boruta methods ({avg_consensus_rate:.1%} average consensus)\")\n        conclusions.append(\"Recommendation: Focus on consensus features for most robust biological screening\")\n    elif avg_consensus_rate > 0.4:\n        conclusions.append(f\"\u26a0\ufe0f Moderate agreement between methods ({avg_consensus_rate:.1%} average consensus)\")  \n        conclusions.append(\"Recommendation: Use both approaches to capture different aspects of biological patterns\")\n    else:\n        conclusions.append(f\"\u274c Low agreement between methods ({avg_consensus_rate:.1%} average consensus)\")\n        conclusions.append(\"Recommendation: Investigate why methods disagree - may indicate complex biological relationships\")\nelse:\n    conclusions.append(\"\u26a0\ufe0f Boruta analysis not available - using MI + Random Forest importance for feature selection\")\n    conclusions.append(\"Recommendation: Install Boruta package for full Transue methodology implementation\")\n\n# Performance conclusions\nif len(performance_df) > 0:\n    _best_f1 = performance_df['f1'].max()\n    if _best_f1 > 0.8:\n        conclusions.append(f\"\u2705 Excellent model performance achieved (F1={_best_f1:.3f})\")\n        conclusions.append(\"Recommendation: Models ready for biological screening deployment\")\n    elif _best_f1 > 0.7:\n        conclusions.append(f\"\u2705 Good model performance achieved (F1={_best_f1:.3f})\")\n        conclusions.append(\"Recommendation: Models suitable for biological screening with careful validation\")\n    else:\n        conclusions.append(f\"\u26a0\ufe0f Moderate model performance (F1={_best_f1:.3f})\")\n        conclusions.append(\"Recommendation: Consider additional feature engineering or data collection\")\n\n# Feature efficiency conclusions\nif 'Consensus Features' in performance_df['feature_set'].values:\n    consensus_performance = performance_df[performance_df['feature_set'] == 'Consensus Features']['f1'].mean()\n    all_features_performance = performance_df[performance_df['feature_set'] == 'All Features']['f1'].mean()\n\n    if consensus_performance >= all_features_performance * 0.95:  # Within 5% of full performance\n        avg_consensus_features = performance_df[performance_df['feature_set'] == 'Consensus Features']['n_features'].mean()\n        conclusions.append(f\"\u2705 Consensus features maintain {consensus_performance/all_features_performance:.1%} of full performance with {avg_consensus_features:.0f} features\")\n        conclusions.append(\"Recommendation: Use consensus feature set for efficient biological screening\")\n\nfor _i_conc, conclusion in enumerate(conclusions, 1):\n    print(f\"  {_i_conc}. {conclusion}\")\n\nsummary['scientific_conclusions'] = conclusions\n\n# Save summary\nwith open(DATA_ROOT / \"processed/06_01_enhanced_analysis_summary.json\", 'w') as f:\n    json.dump(summary, f, indent=2)\n\nprint(f\"\\n\" + \"=\"*80)\nprint(\"ENHANCED COMMUNITY PATTERN DETECTION ANALYSIS COMPLETE\")\nprint(\"=\"*80)\nprint(f\"\u2705 Comparative feature selection completed\")\nprint(f\"\u2705 Enhanced model validation completed\")\nprint(f\"\u2705 Scientific conclusions documented\")\nprint(f\"\u2705 Results saved for biological screening deployment\")\n\nif BORUTA_AVAILABLE:\n    print(f\"\ud83c\udf32 Boruta methodology successfully integrated\")\nelse:\n    print(f\"\u26a0\ufe0f Install Boruta package for full Transue methodology: pip install boruta\")\n\nprint(\"=\"*80)", "code_hash": "bd48d5b2d623ba751ede422ab95a6053", "config": {"column": null, "disabled": false, "hide_code": false}, "id": "iLit", "name": "_"}], "metadata": {"marimo_version": "0.16.0"}, "version": "1"},
            "session": {"cells": [{"code_hash": "76d4331613b8a0dfae89ef9e3e1604a4", "console": [], "id": "Hbol", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h1 id=\"notebook-61-enhanced-community-pattern-detection-with-transue-methodology\">Notebook 6.1: Enhanced Community Pattern Detection with Transue Methodology</h1>\n<span class=\"paragraph\"><strong>Purpose</strong>: Demonstrate that acoustic indices can detect community-level fish patterns using both traditional and state-of-the-art marine bioacoustics methodologies</span>\n<span class=\"paragraph\"><strong>Key Outputs</strong>: Comparative analysis using both Mutual Information and Boruta feature selection with Transue et al. (2023) statistical validation</span>\n<span class=\"paragraph\"><strong>Methodological Enhancement</strong>: This notebook builds upon the original community detection approach by integrating the Random Forest + Boruta methodology established by Transue et al. (2023) for Charleston Harbor soundscape analysis, while maintaining our original Mutual Information approach for comparison.</span>\n<hr />\n<h2 id=\"overview\">Overview</h2>\n<span class=\"paragraph\">This enhanced analysis combines two complementary feature selection approaches:</span>\n<h3 id=\"1-mutual-information-approach-original\">1. Mutual Information Approach (Original)</h3>\n<ul>\n<li><strong>What it does</strong>: Detects non-linear relationships between acoustic indices and biological activity</li>\n<li><strong>Strength</strong>: Captures complex, threshold-based biological relationships</li>\n<li><strong>Best for</strong>: Discovering unexpected acoustic-biological connections</li>\n</ul>\n<h3 id=\"2-boruta-random-forest-approach-transue-et-al-2023\">2. Boruta + Random Forest Approach (Transue et al. 2023)</h3>\n<ul>\n<li><strong>What it does</strong>: Uses ensemble decision trees to identify all relevant features</li>\n<li><strong>Strength</strong>: Established methodology for marine bioacoustics research</li>\n<li><strong>Best for</strong>: Consistent, interpretable feature selection aligned with field standards</li>\n</ul>\n<h2 id=\"why-use-both-approaches\">Why Use Both Approaches?</h2>\n<span class=\"paragraph\"><strong>Complementary Insights</strong>: \n- Mutual Information might find acoustic indices that respond to biological \"hotspots\" or threshold events\n- Boruta might identify indices that consistently track biological patterns across all activity levels\n- Comparing results validates feature importance across different statistical frameworks</span>\n<span class=\"paragraph\"><strong>Scientific Rigor</strong>: \n- Shows our findings are robust across multiple analytical approaches\n- Aligns with established marine bioacoustics methodology (Transue et al.)\n- Provides comprehensive feature evaluation for biological screening applications</span>\n<h2 id=\"enhanced-validation-framework\">Enhanced Validation Framework</h2>\n<span class=\"paragraph\">Following Transue et al. (2023), we implement:\n- <strong>Random Forest modeling</strong> as the primary analytical framework\n- <strong>Boruta feature selection</strong> for systematic feature importance\n- <strong>Out-of-bag validation</strong> and cross-validation for robust performance estimates\n- <strong>Dunnett-Tukey-Kramer post-hoc testing</strong> for statistical significance validation</span>\n<span class=\"paragraph\">The key question remains: <strong>\"Can acoustic indices tell us when to pay attention?\"</strong> but now with enhanced methodological rigor.</span></span>"}, "type": "data"}]}, {"code_hash": "027743bc29991607e2ec7921d858ce5a", "console": [{"name": "stdout", "text": "\u26a0\ufe0f Boruta package not available - install with: pip install boruta\n   Falling back to mutual information + random forest importance only\n\u2705 Post-hoc testing available\nLibraries loaded successfully\nData root: /Users/michelleweirathmueller/Documents/WORKSPACE/MBON-USC-2025/mbon-dash-2025/data\nPlot directory: /Users/michelleweirathmueller/Documents/WORKSPACE/MBON-USC-2025/mbon-dash-2025/dashboard/public/views/notebooks\n", "type": "stream"}], "id": "MJUe", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "49f453afcb44f02d2944da9bb20d8910", "console": [], "id": "vblA", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"data-loading-and-preparation\">Data Loading and Preparation</h2>\n<span class=\"paragraph\">Loading all processed datasets and preparing them for enhanced community-level analysis.</span></span>"}, "type": "data"}]}, {"code_hash": "451d020d4b2dc74786817904d45ac98b", "console": [{"name": "stdout", "text": "Loading processed datasets...\n", "type": "stream"}, {"name": "stdout", "text": "\u2705 Loaded enhanced marine community data: (13140, 20)\nIndices shape: (13100, 21)\nDetections shape: (13140, 14)\nEnvironmental shape: (13140, 26)\nTemporal features shape: (13140, 14)\n", "type": "stream"}], "id": "bkHC", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "ad9f6a7acd370fb70c7b9945606c4ec2", "console": [{"name": "stdout", "text": "Master dataset shape: (13100, 37)\nFish species columns (7): ['Silver perch', 'Oyster toadfish boat whistle', 'Oyster toadfish grunt', 'Black drum', 'Spotted seatrout', 'Red drum', 'Atlantic croaker']\nAcoustic index columns (18): ['ACTspFract', 'EPS_KURT', 'ECU', 'NBPEAKS', 'TFSD']...\n", "type": "stream"}], "id": "lEQa", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "c616b351a860a0a50d250256557453b5", "console": [], "id": "PKri", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"community-activity-metrics-creation\">Community Activity Metrics Creation</h2>\n<span class=\"paragraph\">Creating aggregate community-level metrics that move beyond species-specific analysis.</span>\n<h2 id=\"strategy-from-species-specific-to-community-level-analysis\">Strategy: From Species-Specific to Community-Level Analysis</h2>\n<span class=\"paragraph\">Instead of trying to predict individual species calling patterns, we aggregate across all species to ask: \n<strong>\"Is there biological activity happening?\"</strong> This approach:</span>\n<ol>\n<li><strong>Reduces complexity</strong>: 7 species \u00d7 4 intensity levels = 28 possible states \u2192 4 binary questions</li>\n<li><strong>Increases signal</strong>: Combines weak species-specific signals into stronger community signal  </li>\n<li><strong>Matches practical needs</strong>: Often we care more about \"when to listen carefully\" than \"exactly which species\"</li>\n<li><strong>Improves statistical power</strong>: More balanced classes, clearer patterns</li>\n</ol></span>"}, "type": "data"}]}, {"code_hash": "e834eb354ab16d4bd9cf76e0ca3174b2", "console": [{"name": "stdout", "text": "Creating community activity metrics...\nWorking with 7 fish species: ['Silver perch', 'Oyster toadfish boat whistle', 'Oyster toadfish grunt', 'Black drum', 'Spotted seatrout', 'Red drum', 'Atlantic croaker']\nFish community metrics created. Sample statistics:\n", "type": "stream"}, {"name": "stdout", "text": "Total activity - Mean: 1.58\nHigh activity (75th): 25.5%\nAny activity: 53.9%\n", "type": "stream"}], "id": "Xref", "outputs": [{"data": {"text/plain": ""}, "type": "data"}]}, {"code_hash": "6f4f11e1d9d3a4cd102d15d039008941", "console": [], "id": "SFPL", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"enhanced-feature-selection-comparative-analysis\">Enhanced Feature Selection: Comparative Analysis</h2>\n<span class=\"paragraph\">This section implements both traditional and state-of-the-art feature selection approaches to identify the most important acoustic indices for biological screening.</span>\n<h2 id=\"methodological-comparison\">Methodological Comparison</h2>\n<h3 id=\"approach-1-mutual-information-original-method\">Approach 1: Mutual Information (Original Method)</h3>\n<span class=\"paragraph\"><strong>What it does</strong>: Measures how much information one variable provides about another, capturing both linear and non-linear relationships.</span>\n<span class=\"paragraph\"><strong>Biological relevance</strong>: \n- Can detect threshold effects (e.g., fish only call when certain acoustic conditions are met)\n- Captures complex interaction patterns between indices and biology\n- Good for discovering unexpected acoustic-biological relationships</span>\n<h3 id=\"approach-2-boruta-random-forest-transue-et-al-2023\">Approach 2: Boruta + Random Forest (Transue et al. 2023)</h3>\n<span class=\"paragraph\"><strong>What it does</strong>: Uses an ensemble of decision trees to systematically identify all statistically relevant features.</span>\n<span class=\"paragraph\"><strong>Biological relevance</strong>:\n- Established methodology in marine bioacoustics research\n- Handles feature interactions naturally through tree-based decisions\n- Provides consistent, interpretable feature rankings\n- Proven approach for acoustic data with temporal autocorrelation</span>\n<h2 id=\"why-compare-both\">Why Compare Both?</h2>\n<span class=\"paragraph\"><strong>Scientific validation</strong>: If both methods identify the same indices as important, we have strong evidence for their biological relevance.</span>\n<span class=\"paragraph\"><strong>Methodological robustness</strong>: Shows our findings aren't dependent on a single analytical approach.</span>\n<span class=\"paragraph\"><strong>Best of both worlds</strong>: Combines novel discovery potential (MI) with established field methodology (Boruta).</span></span>"}, "type": "data"}]}, {"code_hash": "db9ed82d8ce60c95c3b9fc804e270a09", "console": [{"name": "stdout", "text": "ENHANCED FEATURE SELECTION: COMPARATIVE ANALYSIS\n======================================================================\nImplementing both Mutual Information and Boruta approaches\n======================================================================\nFeature categories:\n  - Acoustic indices: 18 variables\n  - Environmental: 2 variables (temperature, depth)\n  - Temporal: 2 variables (hour, month)\n  - Total features: 22\nModeling dataset: 13,100 complete samples\n\n==================================================\nANALYZING TARGET: high_activity_75th\n==================================================\nClass balance: {0: 0.7448091603053435, 1: 0.2551908396946565}\n\n1. MUTUAL INFORMATION FEATURE SELECTION\n---------------------------------------------\n", "type": "stream"}, {"name": "stdout", "text": "Top 5 features by Mutual Information:\n  1. month (temporal): 0.179\n  2. Water temp (\u00b0C) (environmental): 0.108\n  3. ENRf (acoustic_index): 0.105\n  4. VARf (acoustic_index): 0.101\n  5. H_pairedShannon (acoustic_index): 0.093\n\n2. BORUTA NOT AVAILABLE - USING RANDOM FOREST IMPORTANCE\n-------------------------------------------------------\n", "type": "stream"}, {"name": "stdout", "text": "Top 5 features by Random Forest importance:\n  1. month (temporal): 0.178\n", "type": "stream"}, {"name": "stderr", "text": "<span class=\"codehilite\"><div class=\"highlight\"><pre><span></span><span class=\"gt\">Traceback (most recent call last):</span>\n  File <span class=\"nb\">&quot;/Users/michelleweirathmueller/Documents/WORKSPACE/MBON-USC-2025/mbon-dash-2025/python/.venv/lib/python3.12/site-packages/marimo/_runtime/executor.py&quot;</span>, line <span class=\"m\">138</span>, in <span class=\"n\">execute_cell</span>\n<span class=\"w\">    </span><span class=\"n\">exec</span><span class=\"p\">(</span><span class=\"n\">cell</span><span class=\"o\">.</span><span class=\"n\">body</span><span class=\"p\">,</span> <span class=\"n\">glbls</span><span class=\"p\">)</span>\n  File <span class=\"nb\">&quot;/var/folders/7g/l4jzm4ln40v_5j9zwsmkfrhc0000gn/T/marimo_10296/__marimo__cell_BYtC_.py&quot;</span>, line <span class=\"m\">205</span>, in <span class=\"n\">&lt;module&gt;</span>\n<span class=\"w\">    </span><span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;  </span><span class=\"si\">{</span><span class=\"n\">_i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"si\">}</span><span class=\"s2\">. </span><span class=\"si\">{</span><span class=\"n\">rf_row</span><span class=\"p\">[</span><span class=\"s1\">&#39;feature&#39;</span><span class=\"p\">]</span><span class=\"si\">}</span><span class=\"s2\"> (</span><span class=\"si\">{</span><span class=\"n\">rf_row</span><span class=\"p\">[</span><span class=\"s1\">&#39;feature_type&#39;</span><span class=\"p\">]</span><span class=\"si\">}</span><span class=\"s2\">): </span><span class=\"si\">{</span><span class=\"n\">rf_row</span><span class=\"p\">[</span><span class=\"s1\">&#39;rf_importance&#39;</span><span class=\"p\">]</span><span class=\"si\">:</span><span class=\"s2\">.3f</span><span class=\"si\">}</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n<span class=\"w\">               </span><span class=\"pm\">^^</span>\n<span class=\"gr\">NameError</span>: <span class=\"n\">name &#39;_i&#39; is not defined</span>\n</pre></div>\n</span>", "type": "stream"}], "id": "BYtC", "outputs": [{"ename": "exception", "evalue": "name '_i' is not defined", "traceback": [], "type": "error"}]}, {"code_hash": "180509900f132d01efc2695e34ce562f", "console": [], "id": "RGSE", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"enhanced-model-development-with-transue-methodology\">Enhanced Model Development with Transue Methodology</h2>\n<span class=\"paragraph\">Training machine learning models using the enhanced feature selection results, with emphasis on Random Forest modeling following Transue et al. (2023).</span>\n<h2 id=\"model-selection-strategy\">Model Selection Strategy</h2>\n<span class=\"paragraph\"><strong>Primary Focus: Random Forest</strong> (following Transue et al.)\n- Proven methodology for marine bioacoustic data\n- Handles temporal autocorrelation naturally\n- Provides interpretable feature importance\n- Robust to outliers and missing data</span>\n<span class=\"paragraph\"><strong>Comparative Models</strong> (for validation):\n- Logistic Regression: Linear baseline\n- Decision Tree: Simple interpretable rules</span>\n<h2 id=\"enhanced-validation-framework\">Enhanced Validation Framework</h2>\n<span class=\"paragraph\">Following Transue et al. (2023):\n- <strong>Out-of-bag error estimation</strong> (built into Random Forest)\n- <strong>Stratified cross-validation</strong> for robust performance estimates<br />\n- <strong>Feature importance ranking</strong> with statistical significance\n- <strong>Model performance on both consensus and method-specific features</strong></span></span>"}, "type": "data"}]}, {"code_hash": "98e06a431f10ffb68cb55f1dd8774516", "console": [], "id": "Kclp", "outputs": [{"ename": "exception", "evalue": "An ancestor raised an exception (NameError): ", "traceback": [], "type": "error"}]}, {"code_hash": "9f3f64c6bfc055dd95f3af1c20465f3d", "console": [], "id": "emfo", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"enhanced-results-analysis-and-visualization\">Enhanced Results Analysis and Visualization</h2>\n<span class=\"paragraph\">Comprehensive analysis of feature selection and model performance, comparing traditional and Transue methodologies.</span></span>"}, "type": "data"}]}, {"code_hash": "b13682ee689303ed8be4c3b5fcd845c1", "console": [], "id": "Hstk", "outputs": [{"ename": "exception", "evalue": "An ancestor raised an exception (NameError): ", "traceback": [], "type": "error"}]}, {"code_hash": "4d81c06c5ff91bc699602b80da971a7b", "console": [], "id": "nWHF", "outputs": [{"data": {"text/html": "<span class=\"markdown prose dark:prose-invert\"><h2 id=\"comprehensive-results-summary-and-scientific-interpretation\">Comprehensive Results Summary and Scientific Interpretation</h2>\n<span class=\"paragraph\">Synthesizing findings from the enhanced comparative analysis to provide actionable insights for biological screening.</span></span>"}, "type": "data"}]}, {"code_hash": "bd48d5b2d623ba751ede422ab95a6053", "console": [], "id": "iLit", "outputs": [{"ename": "exception", "evalue": "An ancestor raised an exception (NameError): ", "traceback": [], "type": "error"}]}], "metadata": {"marimo_version": "0.16.0"}, "version": "1"},
            "runtimeConfig": null,
        };
    </script>
  
<marimo-code hidden="">
    import%20marimo%0A%0A__generated_with%20%3D%20%220.16.0%22%0Aapp%20%3D%20marimo.App(width%3D%22medium%22)%0A%0A%0A%40app.cell(hide_code%3DTrue)%0Adef%20_()%3A%0A%20%20%20%20import%20marimo%20as%20mo%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20r%22%22%22%0A%20%20%20%20%20%20%20%20%23%20Notebook%206.1%3A%20Enhanced%20Community%20Pattern%20Detection%20with%20Transue%20Methodology%0A%0A%20%20%20%20%20%20%20%20**Purpose**%3A%20Demonstrate%20that%20acoustic%20indices%20can%20detect%20community-level%20fish%20patterns%20using%20both%20traditional%20and%20state-of-the-art%20marine%20bioacoustics%20methodologies%0A%0A%20%20%20%20%20%20%20%20**Key%20Outputs**%3A%20Comparative%20analysis%20using%20both%20Mutual%20Information%20and%20Boruta%20feature%20selection%20with%20Transue%20et%20al.%20(2023)%20statistical%20validation%0A%0A%20%20%20%20%20%20%20%20**Methodological%20Enhancement**%3A%20This%20notebook%20builds%20upon%20the%20original%20community%20detection%20approach%20by%20integrating%20the%20Random%20Forest%20%2B%20Boruta%20methodology%20established%20by%20Transue%20et%20al.%20(2023)%20for%20Charleston%20Harbor%20soundscape%20analysis%2C%20while%20maintaining%20our%20original%20Mutual%20Information%20approach%20for%20comparison.%0A%0A%20%20%20%20%20%20%20%20---%0A%0A%20%20%20%20%20%20%20%20%23%23%20Overview%0A%0A%20%20%20%20%20%20%20%20This%20enhanced%20analysis%20combines%20two%20complementary%20feature%20selection%20approaches%3A%0A%0A%20%20%20%20%20%20%20%20%23%23%23%201.%20Mutual%20Information%20Approach%20(Original)%0A%20%20%20%20%20%20%20%20-%20**What%20it%20does**%3A%20Detects%20non-linear%20relationships%20between%20acoustic%20indices%20and%20biological%20activity%0A%20%20%20%20%20%20%20%20-%20**Strength**%3A%20Captures%20complex%2C%20threshold-based%20biological%20relationships%0A%20%20%20%20%20%20%20%20-%20**Best%20for**%3A%20Discovering%20unexpected%20acoustic-biological%20connections%0A%0A%20%20%20%20%20%20%20%20%23%23%23%202.%20Boruta%20%2B%20Random%20Forest%20Approach%20(Transue%20et%20al.%202023)%0A%20%20%20%20%20%20%20%20-%20**What%20it%20does**%3A%20Uses%20ensemble%20decision%20trees%20to%20identify%20all%20relevant%20features%0A%20%20%20%20%20%20%20%20-%20**Strength**%3A%20Established%20methodology%20for%20marine%20bioacoustics%20research%0A%20%20%20%20%20%20%20%20-%20**Best%20for**%3A%20Consistent%2C%20interpretable%20feature%20selection%20aligned%20with%20field%20standards%0A%0A%20%20%20%20%20%20%20%20%23%23%20Why%20Use%20Both%20Approaches%3F%0A%0A%20%20%20%20%20%20%20%20**Complementary%20Insights**%3A%20%0A%20%20%20%20%20%20%20%20-%20Mutual%20Information%20might%20find%20acoustic%20indices%20that%20respond%20to%20biological%20%22hotspots%22%20or%20threshold%20events%0A%20%20%20%20%20%20%20%20-%20Boruta%20might%20identify%20indices%20that%20consistently%20track%20biological%20patterns%20across%20all%20activity%20levels%0A%20%20%20%20%20%20%20%20-%20Comparing%20results%20validates%20feature%20importance%20across%20different%20statistical%20frameworks%0A%0A%20%20%20%20%20%20%20%20**Scientific%20Rigor**%3A%20%0A%20%20%20%20%20%20%20%20-%20Shows%20our%20findings%20are%20robust%20across%20multiple%20analytical%20approaches%0A%20%20%20%20%20%20%20%20-%20Aligns%20with%20established%20marine%20bioacoustics%20methodology%20(Transue%20et%20al.)%0A%20%20%20%20%20%20%20%20-%20Provides%20comprehensive%20feature%20evaluation%20for%20biological%20screening%20applications%0A%0A%20%20%20%20%20%20%20%20%23%23%20Enhanced%20Validation%20Framework%0A%0A%20%20%20%20%20%20%20%20Following%20Transue%20et%20al.%20(2023)%2C%20we%20implement%3A%0A%20%20%20%20%20%20%20%20-%20**Random%20Forest%20modeling**%20as%20the%20primary%20analytical%20framework%0A%20%20%20%20%20%20%20%20-%20**Boruta%20feature%20selection**%20for%20systematic%20feature%20importance%0A%20%20%20%20%20%20%20%20-%20**Out-of-bag%20validation**%20and%20cross-validation%20for%20robust%20performance%20estimates%0A%20%20%20%20%20%20%20%20-%20**Dunnett-Tukey-Kramer%20post-hoc%20testing**%20for%20statistical%20significance%20validation%0A%0A%20%20%20%20%20%20%20%20The%20key%20question%20remains%3A%20**%22Can%20acoustic%20indices%20tell%20us%20when%20to%20pay%20attention%3F%22**%20but%20now%20with%20enhanced%20methodological%20rigor.%0A%20%20%20%20%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%20(mo%2C)%0A%0A%0A%40app.cell(hide_code%3DTrue)%0Adef%20_()%3A%0A%20%20%20%20import%20pandas%20as%20pd%0A%20%20%20%20import%20numpy%20as%20np%0A%20%20%20%20import%20matplotlib.pyplot%20as%20plt%0A%20%20%20%20import%20seaborn%20as%20sns%0A%20%20%20%20from%20pathlib%20import%20Path%0A%20%20%20%20import%20warnings%0A%20%20%20%20import%20json%0A%20%20%20%20import%20pickle%0A%20%20%20%20warnings.filterwarnings('ignore')%0A%0A%20%20%20%20%23%20Machine%20learning%0A%20%20%20%20from%20sklearn.model_selection%20import%20train_test_split%2C%20cross_val_score%2C%20StratifiedKFold%2C%20TimeSeriesSplit%0A%20%20%20%20from%20sklearn.linear_model%20import%20LogisticRegression%0A%20%20%20%20from%20sklearn.tree%20import%20DecisionTreeClassifier%0A%20%20%20%20from%20sklearn.ensemble%20import%20RandomForestClassifier%2C%20GradientBoostingClassifier%0A%20%20%20%20from%20sklearn.preprocessing%20import%20StandardScaler%2C%20RobustScaler%0A%20%20%20%20from%20sklearn.metrics%20import%20(%0A%20%20%20%20%20%20%20%20classification_report%2C%20confusion_matrix%2C%20roc_curve%2C%20auc%2C%0A%20%20%20%20%20%20%20%20precision_recall_curve%2C%20accuracy_score%2C%20cohen_kappa_score%2C%0A%20%20%20%20%20%20%20%20f1_score%2C%20precision_score%2C%20recall_score%0A%20%20%20%20)%0A%20%20%20%20from%20sklearn.feature_selection%20import%20mutual_info_classif%2C%20SelectKBest%0A%0A%20%20%20%20%23%20Enhanced%20feature%20selection%20(Transue%20methodology)%0A%20%20%20%20try%3A%0A%20%20%20%20%20%20%20%20from%20boruta%20import%20BorutaPy%0A%20%20%20%20%20%20%20%20BORUTA_AVAILABLE%20%3D%20True%0A%20%20%20%20%20%20%20%20print(%22%E2%9C%85%20Boruta%20package%20available%20-%20enhanced%20feature%20selection%20enabled%22)%0A%20%20%20%20except%20ImportError%3A%0A%20%20%20%20%20%20%20%20BORUTA_AVAILABLE%20%3D%20False%0A%20%20%20%20%20%20%20%20print(%22%E2%9A%A0%EF%B8%8F%20Boruta%20package%20not%20available%20-%20install%20with%3A%20pip%20install%20boruta%22)%0A%20%20%20%20%20%20%20%20print(%22%20%20%20Falling%20back%20to%20mutual%20information%20%2B%20random%20forest%20importance%20only%22)%0A%0A%20%20%20%20%23%20Statistical%20analysis%20and%20post-hoc%20testing%0A%20%20%20%20from%20scipy%20import%20stats%0A%20%20%20%20from%20scipy.stats%20import%20spearmanr%2C%20pearsonr%0A%20%20%20%20try%3A%0A%20%20%20%20%20%20%20%20from%20scipy.stats%20import%20tukey_hsd%0A%20%20%20%20%20%20%20%20POSTHOC_AVAILABLE%20%3D%20True%0A%20%20%20%20%20%20%20%20print(%22%E2%9C%85%20Post-hoc%20testing%20available%22)%0A%20%20%20%20except%20ImportError%3A%0A%20%20%20%20%20%20%20%20POSTHOC_AVAILABLE%20%3D%20False%0A%20%20%20%20%20%20%20%20print(%22%E2%9A%A0%EF%B8%8F%20Advanced%20post-hoc%20testing%20not%20available%20-%20using%20basic%20statistical%20tests%22)%0A%0A%20%20%20%20%23%20Set%20plotting%20style%0A%20%20%20%20plt.style.use('default')%0A%20%20%20%20sns.set_palette(%22husl%22)%0A%0A%20%20%20%20%23%20Find%20project%20root%20by%20looking%20for%20the%20data%20folder%0A%20%20%20%20current_dir%20%3D%20Path(__file__).parent%20if%20%22__file__%22%20in%20locals()%20else%20Path.cwd()%0A%20%20%20%20project_root%20%3D%20current_dir%0A%20%20%20%20while%20not%20(project_root%20%2F%20%22data%22).exists()%20and%20project_root%20!%3D%20project_root.parent%3A%0A%20%20%20%20%20%20%20%20project_root%20%3D%20project_root.parent%0A%0A%20%20%20%20%23%20Data%20directories%0A%20%20%20%20DATA_ROOT%20%3D%20project_root%20%2F%20%22data%22%0A%20%20%20%20data_dir%20%3D%20DATA_ROOT%20%2F%20%22processed%22%0A%20%20%20%20plot_dir%20%3D%20DATA_ROOT.parent%20%2F%20%22dashboard%2Fpublic%2Fviews%2Fnotebooks%22%0A%20%20%20%20plot_dir.mkdir(exist_ok%3DTrue%2C%20parents%3DTrue)%0A%0A%20%20%20%20print(%22Libraries%20loaded%20successfully%22)%0A%20%20%20%20print(f%22Data%20root%3A%20%7BDATA_ROOT%7D%22)%0A%20%20%20%20print(f%22Plot%20directory%3A%20%7Bplot_dir%7D%22)%0A%20%20%20%20return%20(%0A%20%20%20%20%20%20%20%20BORUTA_AVAILABLE%2C%0A%20%20%20%20%20%20%20%20BorutaPy%2C%0A%20%20%20%20%20%20%20%20DATA_ROOT%2C%0A%20%20%20%20%20%20%20%20DecisionTreeClassifier%2C%0A%20%20%20%20%20%20%20%20LogisticRegression%2C%0A%20%20%20%20%20%20%20%20RandomForestClassifier%2C%0A%20%20%20%20%20%20%20%20StandardScaler%2C%0A%20%20%20%20%20%20%20%20StratifiedKFold%2C%0A%20%20%20%20%20%20%20%20accuracy_score%2C%0A%20%20%20%20%20%20%20%20cohen_kappa_score%2C%0A%20%20%20%20%20%20%20%20cross_val_score%2C%0A%20%20%20%20%20%20%20%20f1_score%2C%0A%20%20%20%20%20%20%20%20json%2C%0A%20%20%20%20%20%20%20%20mutual_info_classif%2C%0A%20%20%20%20%20%20%20%20np%2C%0A%20%20%20%20%20%20%20%20pd%2C%0A%20%20%20%20%20%20%20%20pickle%2C%0A%20%20%20%20%20%20%20%20plot_dir%2C%0A%20%20%20%20%20%20%20%20plt%2C%0A%20%20%20%20%20%20%20%20precision_score%2C%0A%20%20%20%20%20%20%20%20recall_score%2C%0A%20%20%20%20%20%20%20%20train_test_split%2C%0A%20%20%20%20)%0A%0A%0A%40app.cell(hide_code%3DTrue)%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20r%22%22%22%0A%20%20%20%20%23%23%20Data%20Loading%20and%20Preparation%0A%0A%20%20%20%20Loading%20all%20processed%20datasets%20and%20preparing%20them%20for%20enhanced%20community-level%20analysis.%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(DATA_ROOT%2C%20pd)%3A%0A%20%20%20%20%23%20Load%20all%20processed%20datasets%20(same%20as%20original)%0A%20%20%20%20print(%22Loading%20processed%20datasets...%22)%0A%0A%20%20%20%20%23%20Load%20reduced%20acoustic%20indices%20from%20Notebook%203%0A%20%20%20%20df_indices%20%3D%20pd.read_parquet(DATA_ROOT%20%2F%20%22processed%2F03_reduced_acoustic_indices.parquet%22)%0A%0A%20%20%20%20%23%20Load%20aligned%20detections%20(original%20fish-only%20data)%0A%20%20%20%20df_detections%20%3D%20pd.read_parquet(DATA_ROOT%20%2F%20%22processed%2F02_detections_aligned_2021.parquet%22)%0A%0A%20%20%20%20%23%20Load%20enhanced%20marine%20community%20data%20(fish%20%2B%20dolphins%20from%20notebook%2008)%0A%20%20%20%20marine_community_file%20%3D%20DATA_ROOT%20%2F%20%22processed%2F02_detections_with_marine_community.parquet%22%0A%20%20%20%20if%20marine_community_file.exists()%3A%0A%20%20%20%20%20%20%20%20df_marine_community%20%3D%20pd.read_parquet(marine_community_file)%0A%20%20%20%20%20%20%20%20print(f%22%E2%9C%85%20Loaded%20enhanced%20marine%20community%20data%3A%20%7Bdf_marine_community.shape%7D%22)%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20print(f%22%E2%9A%A0%EF%B8%8F%20Marine%20community%20data%20not%20found%3A%20%7Bmarine_community_file%7D%22)%0A%20%20%20%20%20%20%20%20print(%22Run%20notebook%2008%20first%20to%20generate%20marine%20community%20metrics%22)%0A%20%20%20%20%20%20%20%20df_marine_community%20%3D%20None%0A%0A%20%20%20%20%23%20Load%20environmental%20data%0A%20%20%20%20df_env%20%3D%20pd.read_parquet(DATA_ROOT%20%2F%20%22processed%2F02_environmental_aligned_2021.parquet%22)%0A%0A%20%20%20%20%23%20Load%20temporal%20features%0A%20%20%20%20df_temporal%20%3D%20pd.read_parquet(DATA_ROOT%20%2F%20%22processed%2F02_temporal_features_2021.parquet%22)%0A%0A%20%20%20%20%23%20Load%20detection%20metadata%20to%20identify%20fish%20species%0A%20%20%20%20df_det_metadata%20%3D%20pd.read_parquet(DATA_ROOT%20%2F%20%22processed%2Fmetadata%2F01_detection_columns.parquet%22)%0A%0A%20%20%20%20print(f%22Indices%20shape%3A%20%7Bdf_indices.shape%7D%22)%0A%20%20%20%20print(f%22Detections%20shape%3A%20%7Bdf_detections.shape%7D%22)%0A%20%20%20%20print(f%22Environmental%20shape%3A%20%7Bdf_env.shape%7D%22)%20%0A%20%20%20%20print(f%22Temporal%20features%20shape%3A%20%7Bdf_temporal.shape%7D%22)%0A%20%20%20%20return%20df_det_metadata%2C%20df_detections%2C%20df_env%2C%20df_indices%2C%20df_temporal%0A%0A%0A%40app.cell%0Adef%20_(df_det_metadata%2C%20df_detections%2C%20df_env%2C%20df_indices%2C%20df_temporal)%3A%0A%20%20%20%20%23%20Get%20fish%20species%20columns%0A%20%20%20%20fish_species%20%3D%20df_det_metadata%5B%0A%20%20%20%20%20%20%20%20(df_det_metadata%5B'group'%5D%20%3D%3D%20'fish')%20%26%0A%20%20%20%20%20%20%20%20(df_det_metadata%5B'keep_species'%5D%20%3D%3D%201)%0A%20%20%20%20%5D%5B'long_name'%5D.tolist()%0A%0A%20%20%20%20%23%20Get%20acoustic%20index%20columns%20(exclude%20metadata)%0A%20%20%20%20index_cols%20%3D%20%5Bcol%20for%20col%20in%20df_indices.columns%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20col%20not%20in%20%5B'datetime'%2C%20'station'%2C%20'year'%5D%5D%0A%0A%20%20%20%20%23%20Merge%20all%20datasets%0A%20%20%20%20df_master%20%3D%20df_indices.merge(%0A%20%20%20%20%20%20%20%20df_detections%5B%5B'datetime'%2C%20'station'%2C%20'year'%5D%20%2B%20fish_species%5D%2C%0A%20%20%20%20%20%20%20%20on%3D%5B'datetime'%2C%20'station'%2C%20'year'%5D%2C%0A%20%20%20%20%20%20%20%20how%3D'left'%0A%20%20%20%20)%0A%0A%20%20%20%20df_master%20%3D%20df_master.merge(%0A%20%20%20%20%20%20%20%20df_env%5B%5B'datetime'%2C%20'station'%2C%20'year'%2C%20'Water%20temp%20(%C2%B0C)'%2C%20'Water%20depth%20(m)'%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'Broadband%20(1-40000%20Hz)'%2C%20'Low%20(50-1200%20Hz)'%2C%20'High%20(7000-40000%20Hz)'%5D%5D%2C%0A%20%20%20%20%20%20%20%20on%3D%5B'datetime'%2C%20'station'%2C%20'year'%5D%2C%0A%20%20%20%20%20%20%20%20how%3D'left'%0A%20%20%20%20)%0A%0A%20%20%20%20df_master%20%3D%20df_master.merge(%0A%20%20%20%20%20%20%20%20df_temporal%5B%5B'datetime'%2C%20'station'%2C%20'year'%2C%20'hour'%2C%20'month'%2C%20'season'%2C%20'time_period'%5D%5D%2C%0A%20%20%20%20%20%20%20%20on%3D%5B'datetime'%2C%20'station'%2C%20'year'%5D%2C%0A%20%20%20%20%20%20%20%20how%3D'left'%0A%20%20%20%20)%0A%0A%20%20%20%20%23%20Rename%20time_period%20to%20diel_period%20for%20consistency%0A%20%20%20%20df_master%20%3D%20df_master.rename(columns%3D%7B'time_period'%3A%20'diel_period'%7D)%0A%0A%20%20%20%20print(f%22Master%20dataset%20shape%3A%20%7Bdf_master.shape%7D%22)%0A%20%20%20%20print(f%22Fish%20species%20columns%20(%7Blen(fish_species)%7D)%3A%20%7Bfish_species%7D%22)%0A%20%20%20%20print(f%22Acoustic%20index%20columns%20(%7Blen(index_cols)%7D)%3A%20%7Bindex_cols%5B%3A5%5D%7D...%22)%0A%20%20%20%20return%20df_master%2C%20fish_species%2C%20index_cols%0A%0A%0A%40app.cell(hide_code%3DTrue)%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20r%22%22%22%0A%20%20%20%20%23%23%20Community%20Activity%20Metrics%20Creation%0A%0A%20%20%20%20Creating%20aggregate%20community-level%20metrics%20that%20move%20beyond%20species-specific%20analysis.%0A%0A%20%20%20%20%23%23%20Strategy%3A%20From%20Species-Specific%20to%20Community-Level%20Analysis%0A%0A%20%20%20%20Instead%20of%20trying%20to%20predict%20individual%20species%20calling%20patterns%2C%20we%20aggregate%20across%20all%20species%20to%20ask%3A%20%0A%20%20%20%20**%22Is%20there%20biological%20activity%20happening%3F%22**%20This%20approach%3A%0A%0A%20%20%20%201.%20**Reduces%20complexity**%3A%207%20species%20%C3%97%204%20intensity%20levels%20%3D%2028%20possible%20states%20%E2%86%92%204%20binary%20questions%0A%20%20%20%202.%20**Increases%20signal**%3A%20Combines%20weak%20species-specific%20signals%20into%20stronger%20community%20signal%20%20%0A%20%20%20%203.%20**Matches%20practical%20needs**%3A%20Often%20we%20care%20more%20about%20%22when%20to%20listen%20carefully%22%20than%20%22exactly%20which%20species%22%0A%20%20%20%204.%20**Improves%20statistical%20power**%3A%20More%20balanced%20classes%2C%20clearer%20patterns%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(df_master%2C%20fish_species)%3A%0A%20%20%20%20%23%20Create%20community-level%20activity%20metrics%20(same%20as%20original)%0A%20%20%20%20print(%22Creating%20community%20activity%20metrics...%22)%0A%20%20%20%20print(f%22Working%20with%20%7Blen(fish_species)%7D%20fish%20species%3A%20%7Bfish_species%7D%22)%0A%0A%20%20%20%20%23%20Create%20community%20metrics%0A%20%20%20%20df_community%20%3D%20df_master.copy()%0A%20%20%20%20df_community%5B'total_fish_activity'%5D%20%3D%20df_community%5Bfish_species%5D.sum(axis%3D1)%0A%20%20%20%20df_community%5B'num_active_species'%5D%20%3D%20(df_community%5Bfish_species%5D%20%3E%200).sum(axis%3D1)%0A%20%20%20%20df_community%5B'max_species_activity'%5D%20%3D%20df_community%5Bfish_species%5D.max(axis%3D1)%0A%20%20%20%20df_community%5B'activity_diversity'%5D%20%3D%20df_community%5Bfish_species%5D.std(axis%3D1)%20%2F%20(df_community%5Bfish_species%5D.mean(axis%3D1)%20%2B%200.01)%0A%0A%20%20%20%20%23%20Binary%20classification%20targets%0A%20%20%20%20total_activity_75th%20%3D%20df_community%5B'total_fish_activity'%5D.quantile(0.75)%0A%20%20%20%20total_activity_90th%20%3D%20df_community%5B'total_fish_activity'%5D.quantile(0.90)%0A%0A%20%20%20%20df_community%5B'high_activity_75th'%5D%20%3D%20(df_community%5B'total_fish_activity'%5D%20%3E%3D%20total_activity_75th).astype(int)%0A%20%20%20%20df_community%5B'high_activity_90th'%5D%20%3D%20(df_community%5B'total_fish_activity'%5D%20%3E%3D%20total_activity_90th).astype(int)%0A%20%20%20%20df_community%5B'any_activity'%5D%20%3D%20(df_community%5B'total_fish_activity'%5D%20%3E%200).astype(int)%0A%20%20%20%20df_community%5B'multi_species_active'%5D%20%3D%20(df_community%5B'num_active_species'%5D%20%3E%3D%202).astype(int)%0A%0A%20%20%20%20print(f%22Fish%20community%20metrics%20created.%20Sample%20statistics%3A%22)%0A%20%20%20%20print(f%22Total%20activity%20-%20Mean%3A%20%7Bdf_community%5B'total_fish_activity'%5D.mean()%3A.2f%7D%22)%0A%20%20%20%20print(f%22High%20activity%20(75th)%3A%20%7Bdf_community%5B'high_activity_75th'%5D.mean()%3A.1%25%7D%22)%0A%20%20%20%20print(f%22Any%20activity%3A%20%7Bdf_community%5B'any_activity'%5D.mean()%3A.1%25%7D%22)%0A%20%20%20%20return%20(df_community%2C)%0A%0A%0A%40app.cell(hide_code%3DTrue)%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20r%22%22%22%0A%20%20%20%20%23%23%20Enhanced%20Feature%20Selection%3A%20Comparative%20Analysis%0A%0A%20%20%20%20This%20section%20implements%20both%20traditional%20and%20state-of-the-art%20feature%20selection%20approaches%20to%20identify%20the%20most%20important%20acoustic%20indices%20for%20biological%20screening.%0A%0A%20%20%20%20%23%23%20Methodological%20Comparison%0A%0A%20%20%20%20%23%23%23%20Approach%201%3A%20Mutual%20Information%20(Original%20Method)%0A%20%20%20%20**What%20it%20does**%3A%20Measures%20how%20much%20information%20one%20variable%20provides%20about%20another%2C%20capturing%20both%20linear%20and%20non-linear%20relationships.%0A%0A%20%20%20%20**Biological%20relevance**%3A%20%0A%20%20%20%20-%20Can%20detect%20threshold%20effects%20(e.g.%2C%20fish%20only%20call%20when%20certain%20acoustic%20conditions%20are%20met)%0A%20%20%20%20-%20Captures%20complex%20interaction%20patterns%20between%20indices%20and%20biology%0A%20%20%20%20-%20Good%20for%20discovering%20unexpected%20acoustic-biological%20relationships%0A%0A%20%20%20%20%23%23%23%20Approach%202%3A%20Boruta%20%2B%20Random%20Forest%20(Transue%20et%20al.%202023)%0A%20%20%20%20**What%20it%20does**%3A%20Uses%20an%20ensemble%20of%20decision%20trees%20to%20systematically%20identify%20all%20statistically%20relevant%20features.%0A%0A%20%20%20%20**Biological%20relevance**%3A%0A%20%20%20%20-%20Established%20methodology%20in%20marine%20bioacoustics%20research%0A%20%20%20%20-%20Handles%20feature%20interactions%20naturally%20through%20tree-based%20decisions%0A%20%20%20%20-%20Provides%20consistent%2C%20interpretable%20feature%20rankings%0A%20%20%20%20-%20Proven%20approach%20for%20acoustic%20data%20with%20temporal%20autocorrelation%0A%0A%20%20%20%20%23%23%20Why%20Compare%20Both%3F%0A%0A%20%20%20%20**Scientific%20validation**%3A%20If%20both%20methods%20identify%20the%20same%20indices%20as%20important%2C%20we%20have%20strong%20evidence%20for%20their%20biological%20relevance.%0A%0A%20%20%20%20**Methodological%20robustness**%3A%20Shows%20our%20findings%20aren't%20dependent%20on%20a%20single%20analytical%20approach.%0A%0A%20%20%20%20**Best%20of%20both%20worlds**%3A%20Combines%20novel%20discovery%20potential%20(MI)%20with%20established%20field%20methodology%20(Boruta).%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(%0A%20%20%20%20BORUTA_AVAILABLE%2C%0A%20%20%20%20BorutaPy%2C%0A%20%20%20%20RandomForestClassifier%2C%0A%20%20%20%20StandardScaler%2C%0A%20%20%20%20df_community%2C%0A%20%20%20%20index_cols%2C%0A%20%20%20%20mutual_info_classif%2C%0A%20%20%20%20np%2C%0A%20%20%20%20pd%2C%0A%20%20%20%20rf_results%2C%0A%20%20%20%20rf_row%2C%0A)%3A%0A%20%20%20%20%23%20Enhanced%20Feature%20Selection%3A%20Comparative%20Analysis%0A%20%20%20%20print(%22ENHANCED%20FEATURE%20SELECTION%3A%20COMPARATIVE%20ANALYSIS%22)%0A%20%20%20%20print(%22%3D%22*70)%0A%20%20%20%20print(%22Implementing%20both%20Mutual%20Information%20and%20Boruta%20approaches%22)%0A%20%20%20%20print(%22%3D%22*70)%0A%0A%20%20%20%20%23%20Prepare%20feature%20matrix%0A%20%20%20%20modeling_cols%20%3D%20index_cols%20%2B%20%5B'Water%20temp%20(%C2%B0C)'%2C%20'Water%20depth%20(m)'%2C%20'hour'%2C%20'month'%5D%0A%20%20%20%20target_cols%20%3D%20%5B'high_activity_75th'%2C%20'high_activity_90th'%2C%20'any_activity'%2C%20'multi_species_active'%5D%0A%0A%20%20%20%20print(f%22Feature%20categories%3A%22)%0A%20%20%20%20print(f%22%20%20-%20Acoustic%20indices%3A%20%7Blen(index_cols)%7D%20variables%22)%0A%20%20%20%20print(f%22%20%20-%20Environmental%3A%202%20variables%20(temperature%2C%20depth)%22)%0A%20%20%20%20print(f%22%20%20-%20Temporal%3A%202%20variables%20(hour%2C%20month)%22)%0A%20%20%20%20print(f%22%20%20-%20Total%20features%3A%20%7Blen(modeling_cols)%7D%22)%0A%0A%20%20%20%20%23%20Prepare%20modeling%20dataset%0A%20%20%20%20df_modeling%20%3D%20df_community%5Bmodeling_cols%20%2B%20target_cols%5D.dropna()%0A%20%20%20%20print(f%22Modeling%20dataset%3A%20%7Bdf_modeling.shape%5B0%5D%3A%2C%7D%20complete%20samples%22)%0A%0A%20%20%20%20%23%20Standardize%20features%0A%20%20%20%20X_features%20%3D%20df_modeling%5Bmodeling_cols%5D%0A%20%20%20%20scaler%20%3D%20StandardScaler()%0A%20%20%20%20X_scaled%20%3D%20scaler.fit_transform(X_features)%0A%0A%20%20%20%20%23%20Initialize%20results%20storage%0A%20%20%20%20comparative_feature_results%20%3D%20%7B%7D%0A%0A%20%20%20%20%23%20%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%0A%20%20%20%20%23%20COMPARATIVE%20FEATURE%20SELECTION%20FOR%20EACH%20TARGET%0A%20%20%20%20%23%20%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%3D%0A%0A%20%20%20%20for%20current_target_name%20in%20target_cols%3A%0A%20%20%20%20%20%20%20%20print(f%22%5Cn%22%20%2B%20%22%3D%22*50)%0A%20%20%20%20%20%20%20%20print(f%22ANALYZING%20TARGET%3A%20%7Bcurrent_target_name%7D%22)%0A%20%20%20%20%20%20%20%20print(%22%3D%22*50)%0A%0A%20%20%20%20%20%20%20%20y_target%20%3D%20df_modeling%5Bcurrent_target_name%5D%0A%0A%20%20%20%20%20%20%20%20%23%20Check%20class%20balance%0A%20%20%20%20%20%20%20%20class_balance%20%3D%20y_target.value_counts(normalize%3DTrue)%0A%20%20%20%20%20%20%20%20print(f%22Class%20balance%3A%20%7Bclass_balance.to_dict()%7D%22)%0A%0A%20%20%20%20%20%20%20%20if%20y_target.std()%20%3D%3D%200%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20print(f%22Skipping%20%7Bcurrent_target_name%7D%20-%20no%20variance%20in%20target%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20continue%0A%0A%20%20%20%20%20%20%20%20current_target_results%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20'target_name'%3A%20current_target_name%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20'class_balance'%3A%20class_balance.to_dict()%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20'sample_size'%3A%20len(y_target)%0A%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20%23%20-------------------------------------------------------------%0A%20%20%20%20%20%20%20%20%23%20METHOD%201%3A%20MUTUAL%20INFORMATION%20ANALYSIS%0A%20%20%20%20%20%20%20%20%23%20-------------------------------------------------------------%0A%20%20%20%20%20%20%20%20print(f%22%5Cn1.%20MUTUAL%20INFORMATION%20FEATURE%20SELECTION%22)%0A%20%20%20%20%20%20%20%20print(%22-%22%20*%2045)%0A%0A%20%20%20%20%20%20%20%20%23%20Calculate%20mutual%20information%20scores%0A%20%20%20%20%20%20%20%20mi_scores%20%3D%20mutual_info_classif(X_scaled%2C%20y_target%2C%20random_state%3D42)%0A%0A%20%20%20%20%20%20%20%20%23%20Create%20MI%20results%20dataframe%0A%20%20%20%20%20%20%20%20mi_results%20%3D%20pd.DataFrame(%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20'feature'%3A%20modeling_cols%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20'mi_score'%3A%20mi_scores%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20'feature_type'%3A%20%5B'acoustic_index'%20if%20col%20in%20index_cols%20else%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'environmental'%20if%20col%20in%20%5B'Water%20temp%20(%C2%B0C)'%2C%20'Water%20depth%20(m)'%5D%20else%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'temporal'%20for%20col%20in%20modeling_cols%5D%0A%20%20%20%20%20%20%20%20%7D).sort_values('mi_score'%2C%20ascending%3DFalse)%0A%0A%20%20%20%20%20%20%20%20print(f%22Top%205%20features%20by%20Mutual%20Information%3A%22)%0A%20%20%20%20%20%20%20%20for%20i%2C%20(_%2C%20row)%20in%20enumerate(mi_results.head().iterrows())%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%20%20%7Bi%2B1%7D.%20%7Brow%5B'feature'%5D%7D%20(%7Brow%5B'feature_type'%5D%7D)%3A%20%7Brow%5B'mi_score'%5D%3A.3f%7D%22)%0A%0A%20%20%20%20%20%20%20%20current_target_results%5B'mutual_information'%5D%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20'rankings'%3A%20mi_results%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20'top_5_features'%3A%20mi_results.head()%5B'feature'%5D.tolist()%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20'best_acoustic_index'%3A%20mi_results%5Bmi_results%5B'feature_type'%5D%20%3D%3D%20'acoustic_index'%5D.iloc%5B0%5D%5B'feature'%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20'best_mi_score'%3A%20mi_results.iloc%5B0%5D%5B'mi_score'%5D%0A%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20%23%20-------------------------------------------------------------%0A%20%20%20%20%20%20%20%20%23%20METHOD%202%3A%20BORUTA%20FEATURE%20SELECTION%20(if%20available)%0A%20%20%20%20%20%20%20%20%23%20-------------------------------------------------------------%0A%20%20%20%20%20%20%20%20if%20BORUTA_AVAILABLE%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%5Cn2.%20BORUTA%20%2B%20RANDOM%20FOREST%20FEATURE%20SELECTION%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20print(%22-%22%20*%2050)%0A%20%20%20%20%20%20%20%20%20%20%20%20print(%22Following%20Transue%20et%20al.%20(2023)%20methodology...%22)%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%23%20Initialize%20Random%20Forest%20for%20Boruta%20(matching%20Transue%20parameters)%0A%20%20%20%20%20%20%20%20%20%20%20%20rf_selector%20%3D%20RandomForestClassifier(%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20n_estimators%3D100%2C%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20max_depth%3D8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20random_state%3D42%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20n_jobs%3D-1%20%20%23%20Use%20all%20cores%20for%20faster%20processing%0A%20%20%20%20%20%20%20%20%20%20%20%20)%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%23%20Initialize%20Boruta%0A%20%20%20%20%20%20%20%20%20%20%20%20boruta_selector%20%3D%20BorutaPy(%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20rf_selector%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20n_estimators%3D'auto'%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20verbose%3D0%2C%20%20%23%20Reduce%20output%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20random_state%3D42%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20max_iter%3D100%20%20%23%20Limit%20iterations%20to%20prevent%20long%20runtime%0A%20%20%20%20%20%20%20%20%20%20%20%20)%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20try%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20Fit%20Boruta%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(%22Running%20Boruta%20feature%20selection%20(this%20may%20take%20a%20moment)...%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20boruta_selector.fit(X_scaled%2C%20y_target)%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20Extract%20results%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20selected_features%20%3D%20np.array(modeling_cols)%5Bboruta_selector.support_%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20tentative_features%20%3D%20np.array(modeling_cols)%5Bboruta_selector.support_weak_%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20rejected_features%20%3D%20np.array(modeling_cols)%5B~boruta_selector.support_%20%26%20~boruta_selector.support_weak_%5D%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20Create%20Boruta%20results%20dataframe%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20boruta_results%20%3D%20pd.DataFrame(%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'feature'%3A%20modeling_cols%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'boruta_ranking'%3A%20boruta_selector.ranking_%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'boruta_decision'%3A%20%5B'confirmed'%20if%20boruta_selector.support_%5Bi%5D%20else%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'tentative'%20if%20boruta_selector.support_weak_%5Bi%5D%20else%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'rejected'%20for%20i%20in%20range(len(modeling_cols))%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'feature_type'%3A%20%5B'acoustic_index'%20if%20col%20in%20index_cols%20else%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'environmental'%20if%20col%20in%20%5B'Water%20temp%20(%C2%B0C)'%2C%20'Water%20depth%20(m)'%5D%20else%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'temporal'%20for%20col%20in%20modeling_cols%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D).sort_values('boruta_ranking')%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(f%22Boruta%20Results%3A%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%20%20%E2%9C%85%20Confirmed%20features%3A%20%7Blen(selected_features)%7D%20(%7Blist(selected_features)%7D)%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%20%20%E2%9D%93%20Tentative%20features%3A%20%7Blen(tentative_features)%7D%20(%7Blist(tentative_features)%7D)%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%20%20%E2%9D%8C%20Rejected%20features%3A%20%7Blen(rejected_features)%7D%22)%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20Get%20Random%20Forest%20feature%20importance%20from%20the%20final%20model%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20rf_final%20%3D%20RandomForestClassifier(n_estimators%3D100%2C%20max_depth%3D8%2C%20random_state%3D42)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20rf_final.fit(X_scaled%2C%20y_target)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20rf_importance%20%3D%20rf_final.feature_importances_%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20boruta_results%5B'rf_importance'%5D%20%3D%20rf_importance%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20current_target_results%5B'boruta'%5D%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'rankings'%3A%20boruta_results%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'confirmed_features'%3A%20list(selected_features)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'tentative_features'%3A%20list(tentative_features)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'rejected_features'%3A%20list(rejected_features)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'n_confirmed'%3A%20len(selected_features)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'best_acoustic_index'%3A%20boruta_results%5B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20(boruta_results%5B'feature_type'%5D%20%3D%3D%20'acoustic_index')%20%26%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20(boruta_results%5B'boruta_decision'%5D%20%3D%3D%20'confirmed')%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%5D%5B'feature'%5D.iloc%5B0%5D%20if%20len(selected_features)%20%3E%200%20else%20None%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%0A%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(f%22Top%20confirmed%20features%20by%20ranking%3A%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20confirmed_features%20%3D%20boruta_results%5Bboruta_results%5B'boruta_decision'%5D%20%3D%3D%20'confirmed'%5D.head()%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20for%20i%2C%20(_%2C%20row)%20in%20enumerate(confirmed_features.iterrows())%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%20%20%7Bi%2B1%7D.%20%7Brow%5B'feature'%5D%7D%20(%7Brow%5B'feature_type'%5D%7D)%3A%20rank%20%7Brow%5B'boruta_ranking'%5D%7D%22)%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20except%20Exception%20as%20e%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%E2%9A%A0%EF%B8%8F%20Boruta%20analysis%20failed%20for%20%7Bcurrent_target_name%7D%3A%20%7Bstr(e)%7D%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(%22Falling%20back%20to%20Random%20Forest%20importance%20only...%22)%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20Fallback%20to%20RF%20importance%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20rf_fallback%20%3D%20RandomForestClassifier(n_estimators%3D100%2C%20max_depth%3D8%2C%20random_state%3D42)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20rf_fallback.fit(X_scaled%2C%20y_target)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20rf_importance%20%3D%20rf_fallback.feature_importances_%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20rf_results_df%20%3D%20pd.DataFrame(%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'feature'%3A%20modeling_cols%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'rf_importance'%3A%20rf_importance%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'feature_type'%3A%20%5B'acoustic_index'%20if%20col%20in%20index_cols%20else%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'environmental'%20if%20col%20in%20%5B'Water%20temp%20(%C2%B0C)'%2C%20'Water%20depth%20(m)'%5D%20else%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'temporal'%20for%20col%20in%20modeling_cols%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D).sort_values('rf_importance'%2C%20ascending%3DFalse)%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20current_target_results%5B'boruta'%5D%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'rankings'%3A%20rf_results_df%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'confirmed_features'%3A%20rf_results_df.head(5)%5B'feature'%5D.tolist()%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'fallback_used'%3A%20True%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'best_acoustic_index'%3A%20rf_results%5Brf_results%5B'feature_type'%5D%20%3D%3D%20'acoustic_index'%5D.iloc%5B0%5D%5B'feature'%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%5Cn2.%20BORUTA%20NOT%20AVAILABLE%20-%20USING%20RANDOM%20FOREST%20IMPORTANCE%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20print(%22-%22%20*%2055)%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%23%20Fallback%20to%20RF%20importance%0A%20%20%20%20%20%20%20%20%20%20%20%20rf_fallback%20%3D%20RandomForestClassifier(n_estimators%3D100%2C%20max_depth%3D8%2C%20random_state%3D42)%0A%20%20%20%20%20%20%20%20%20%20%20%20rf_fallback.fit(X_scaled%2C%20y_target)%0A%20%20%20%20%20%20%20%20%20%20%20%20rf_importance%20%3D%20rf_fallback.feature_importances_%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20rf_results_df%20%3D%20pd.DataFrame(%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'feature'%3A%20modeling_cols%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'rf_importance'%3A%20rf_importance%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'feature_type'%3A%20%5B'acoustic_index'%20if%20col%20in%20index_cols%20else%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'environmental'%20if%20col%20in%20%5B'Water%20temp%20(%C2%B0C)'%2C%20'Water%20depth%20(m)'%5D%20else%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'temporal'%20for%20col%20in%20modeling_cols%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D).sort_values('rf_importance'%2C%20ascending%3DFalse)%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20print(f%22Top%205%20features%20by%20Random%20Forest%20importance%3A%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20for%20i%2C%20(_%2C%20row)%20in%20enumerate(rf_results_df.head().iterrows())%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%20%20%7Bi%2B1%7D.%20%7Brow%5B'feature'%5D%7D%20(%7Brow%5B'feature_type'%5D%7D)%3A%20%7Brow%5B'rf_importance'%5D%3A.3f%7D%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%20%20%7B_i%2B1%7D.%20%7Brf_row%5B'feature'%5D%7D%20(%7Brf_row%5B'feature_type'%5D%7D)%3A%20%7Brf_row%5B'rf_importance'%5D%3A.3f%7D%22)%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20current_target_results%5B'boruta'%5D%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'rankings'%3A%20rf_results_df%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'confirmed_features'%3A%20rf_results_df.head(5)%5B'feature'%5D.tolist()%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'fallback_used'%3A%20True%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'best_acoustic_index'%3A%20rf_results%5Brf_results%5B'feature_type'%5D%20%3D%3D%20'acoustic_index'%5D.iloc%5B0%5D%5B'feature'%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20%23%20-------------------------------------------------------------%0A%20%20%20%20%20%20%20%20%23%20METHOD%20COMPARISON%20AND%20CONSENSUS%0A%20%20%20%20%20%20%20%20%23%20-------------------------------------------------------------%0A%20%20%20%20%20%20%20%20print(f%22%5Cn3.%20COMPARATIVE%20ANALYSIS%3A%20MI%20vs%20BORUTA%22)%0A%20%20%20%20%20%20%20%20print(%22-%22%20*%2040)%0A%0A%20%20%20%20%20%20%20%20mi_top_5%20%3D%20set(current_target_results%5B'mutual_information'%5D%5B'top_5_features'%5D)%0A%20%20%20%20%20%20%20%20boruta_top_5%20%3D%20set(current_target_results%5B'boruta'%5D%5B'confirmed_features'%5D%5B%3A5%5D)%0A%0A%20%20%20%20%20%20%20%20_consensus_features%20%3D%20mi_top_5.intersection(boruta_top_5)%0A%20%20%20%20%20%20%20%20mi_unique%20%3D%20mi_top_5%20-%20boruta_top_5%0A%20%20%20%20%20%20%20%20boruta_unique%20%3D%20boruta_top_5%20-%20mi_top_5%0A%0A%20%20%20%20%20%20%20%20print(f%22Feature%20agreement%20analysis%3A%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%F0%9F%A4%9D%20Consensus%20features%20(both%20methods)%3A%20%7Blen(_consensus_features)%7D%22)%0A%20%20%20%20%20%20%20%20if%20_consensus_features%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%20%20%20%20%20%20%7Blist(_consensus_features)%7D%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%F0%9F%94%8D%20MI-unique%20features%3A%20%7Blen(mi_unique)%7D%22)%0A%20%20%20%20%20%20%20%20if%20mi_unique%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%20%20%20%20%20%20%7Blist(mi_unique)%7D%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20%F0%9F%8C%B2%20Boruta-unique%20features%3A%20%7Blen(boruta_unique)%7D%22)%0A%20%20%20%20%20%20%20%20if%20boruta_unique%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%20%20%20%20%20%20%7Blist(boruta_unique)%7D%22)%0A%0A%20%20%20%20%20%20%20%20current_target_results%5B'comparison'%5D%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20'consensus_features'%3A%20list(_consensus_features)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20'mi_unique_features'%3A%20list(mi_unique)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20'boruta_unique_features'%3A%20list(boruta_unique)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20'agreement_rate'%3A%20len(_consensus_features)%20%2F%205.0%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20'total_unique_features'%3A%20len(mi_top_5.union(boruta_top_5))%0A%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20comparative_feature_results%5Bcurrent_target_name%5D%20%3D%20current_target_results%0A%0A%20%20%20%20print(f%22%5Cn%22%20%2B%20%22%3D%22*70)%0A%20%20%20%20print(%22COMPARATIVE%20FEATURE%20SELECTION%20COMPLETE%22)%0A%20%20%20%20print(%22%3D%22*70)%0A%20%20%20%20print(f%22Analyzed%20%7Blen(comparative_feature_results)%7D%20targets%20successfully%22)%0A%20%20%20%20return%20comparative_feature_results%2C%20df_modeling%2C%20modeling_cols%2C%20target_cols%0A%0A%0A%40app.cell(hide_code%3DTrue)%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20r%22%22%22%0A%20%20%20%20%23%23%20Enhanced%20Model%20Development%20with%20Transue%20Methodology%0A%0A%20%20%20%20Training%20machine%20learning%20models%20using%20the%20enhanced%20feature%20selection%20results%2C%20with%20emphasis%20on%20Random%20Forest%20modeling%20following%20Transue%20et%20al.%20(2023).%0A%0A%20%20%20%20%23%23%20Model%20Selection%20Strategy%0A%0A%20%20%20%20**Primary%20Focus%3A%20Random%20Forest**%20(following%20Transue%20et%20al.)%0A%20%20%20%20-%20Proven%20methodology%20for%20marine%20bioacoustic%20data%0A%20%20%20%20-%20Handles%20temporal%20autocorrelation%20naturally%0A%20%20%20%20-%20Provides%20interpretable%20feature%20importance%0A%20%20%20%20-%20Robust%20to%20outliers%20and%20missing%20data%0A%0A%20%20%20%20**Comparative%20Models**%20(for%20validation)%3A%0A%20%20%20%20-%20Logistic%20Regression%3A%20Linear%20baseline%0A%20%20%20%20-%20Decision%20Tree%3A%20Simple%20interpretable%20rules%0A%0A%20%20%20%20%23%23%20Enhanced%20Validation%20Framework%0A%0A%20%20%20%20Following%20Transue%20et%20al.%20(2023)%3A%0A%20%20%20%20-%20**Out-of-bag%20error%20estimation**%20(built%20into%20Random%20Forest)%0A%20%20%20%20-%20**Stratified%20cross-validation**%20for%20robust%20performance%20estimates%20%20%0A%20%20%20%20-%20**Feature%20importance%20ranking**%20with%20statistical%20significance%0A%20%20%20%20-%20**Model%20performance%20on%20both%20consensus%20and%20method-specific%20features**%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(%0A%20%20%20%20DecisionTreeClassifier%2C%0A%20%20%20%20LogisticRegression%2C%0A%20%20%20%20RandomForestClassifier%2C%0A%20%20%20%20StandardScaler%2C%0A%20%20%20%20StratifiedKFold%2C%0A%20%20%20%20accuracy_score%2C%0A%20%20%20%20cohen_kappa_score%2C%0A%20%20%20%20comparative_feature_results%2C%0A%20%20%20%20cross_val_score%2C%0A%20%20%20%20df_modeling%2C%0A%20%20%20%20f1_score%2C%0A%20%20%20%20modeling_cols%2C%0A%20%20%20%20precision_score%2C%0A%20%20%20%20recall_score%2C%0A%20%20%20%20target_cols%2C%0A%20%20%20%20train_test_split%2C%0A)%3A%0A%20%20%20%20%23%20Enhanced%20Model%20Development%0A%20%20%20%20print(%22ENHANCED%20MODEL%20DEVELOPMENT%20WITH%20TRANSUE%20METHODOLOGY%22)%0A%20%20%20%20print(%22%3D%22*70)%0A%20%20%20%20print(%22Primary%20focus%3A%20Random%20Forest%20with%20comparative%20validation%22)%0A%20%20%20%20print(%22%3D%22*70)%0A%0A%20%20%20%20%23%20Model%20configurations%20(emphasizing%20Random%20Forest%20following%20Transue%20et%20al.)%0A%20%20%20%20enhanced_models%20%3D%20%7B%0A%20%20%20%20%20%20%20%20'Random%20Forest%20(Primary)'%3A%20RandomForestClassifier(%0A%20%20%20%20%20%20%20%20%20%20%20%20n_estimators%3D100%2C%20%20%20%20%20%20%23%20Match%20Transue%20parameters%0A%20%20%20%20%20%20%20%20%20%20%20%20max_depth%3D8%2C%20%20%20%20%20%20%20%20%20%20%20%23%20Prevent%20overfitting%0A%20%20%20%20%20%20%20%20%20%20%20%20min_samples_leaf%3D5%2C%20%20%20%20%23%20Ensure%20robust%20nodes%0A%20%20%20%20%20%20%20%20%20%20%20%20oob_score%3DTrue%2C%20%20%20%20%20%20%20%20%23%20Enable%20out-of-bag%20scoring%20(Transue%20method)%0A%20%20%20%20%20%20%20%20%20%20%20%20random_state%3D42%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20n_jobs%3D-1%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20Use%20all%20cores%0A%20%20%20%20%20%20%20%20)%2C%0A%20%20%20%20%20%20%20%20'Random%20Forest%20(Consensus)'%3A%20RandomForestClassifier(%20%20%23%20Will%20use%20consensus%20features%20only%0A%20%20%20%20%20%20%20%20%20%20%20%20n_estimators%3D100%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20max_depth%3D8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20min_samples_leaf%3D5%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20oob_score%3DTrue%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20random_state%3D42%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20n_jobs%3D-1%0A%20%20%20%20%20%20%20%20)%2C%0A%20%20%20%20%20%20%20%20'Logistic%20Regression'%3A%20LogisticRegression(max_iter%3D1000%2C%20random_state%3D42)%2C%0A%20%20%20%20%20%20%20%20'Decision%20Tree'%3A%20DecisionTreeClassifier(%0A%20%20%20%20%20%20%20%20%20%20%20%20max_depth%3D8%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20min_samples_leaf%3D10%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20random_state%3D42%0A%20%20%20%20%20%20%20%20)%2C%0A%20%20%20%20%7D%0A%0A%20%20%20%20print(f%22Model%20configurations%3A%20%7Blist(enhanced_models.keys())%7D%22)%0A%0A%20%20%20%20%23%20Initialize%20enhanced%20results%20storage%0A%20%20%20%20enhanced_model_results%20%3D%20%7B%7D%0A%20%20%20%20feature_performance_comparison%20%3D%20%7B%7D%0A%0A%20%20%20%20for%20_target_name%20in%20target_cols%3A%0A%20%20%20%20%20%20%20%20if%20_target_name%20not%20in%20comparative_feature_results%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20continue%0A%0A%20%20%20%20%20%20%20%20print(f%22%5Cn%22%20%2B%20%22%3D%22*60)%0A%20%20%20%20%20%20%20%20print(f%22TRAINING%20ENHANCED%20MODELS%20FOR%3A%20%7B_target_name%7D%22)%0A%20%20%20%20%20%20%20%20print(%22%3D%22*60)%0A%0A%20%20%20%20%20%20%20%20_y_target%20%3D%20df_modeling%5B_target_name%5D%0A%20%20%20%20%20%20%20%20target_feature_results%20%3D%20comparative_feature_results%5B_target_name%5D%0A%0A%20%20%20%20%20%20%20%20%23%20Get%20different%20feature%20sets%20for%20comparison%0A%20%20%20%20%20%20%20%20all_features%20%3D%20modeling_cols%0A%20%20%20%20%20%20%20%20_consensus_features%20%3D%20target_feature_results%5B'comparison'%5D%5B'consensus_features'%5D%0A%20%20%20%20%20%20%20%20mi_top_features%20%3D%20target_feature_results%5B'mutual_information'%5D%5B'top_5_features'%5D%0A%20%20%20%20%20%20%20%20boruta_top_features%20%3D%20target_feature_results%5B'boruta'%5D%5B'confirmed_features'%5D%5B%3A5%5D%0A%0A%20%20%20%20%20%20%20%20print(f%22Feature%20set%20comparison%3A%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20All%20features%3A%20%7Blen(all_features)%7D%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20Consensus%20features%3A%20%7Blen(_consensus_features)%7D%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20MI%20top%20features%3A%20%7Blen(mi_top_features)%7D%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20Boruta%20top%20features%3A%20%7Blen(boruta_top_features)%7D%22)%0A%0A%20%20%20%20%20%20%20%20target_model_results%20%3D%20%7B%7D%0A%0A%20%20%20%20%20%20%20%20%23%20Test%20different%20feature%20sets%0A%20%20%20%20%20%20%20%20feature_sets%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20'All%20Features'%3A%20all_features%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20'Consensus%20Features'%3A%20_consensus_features%20if%20len(_consensus_features)%20%3E%3D%203%20else%20all_features%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20'MI%20Top%20Features'%3A%20mi_top_features%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20'Boruta%20Top%20Features'%3A%20boruta_top_features%0A%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20for%20feature_set_name%2C%20feature_list%20in%20feature_sets.items()%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%5Cn---%20FEATURE%20SET%3A%20%7Bfeature_set_name%7D%20(%7Blen(feature_list)%7D%20features)%20---%22)%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20len(feature_list)%20%3C%203%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(f%22Skipping%20%7Bfeature_set_name%7D%20-%20insufficient%20features%20(%7Blen(feature_list)%7D)%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20continue%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%23%20Prepare%20features%0A%20%20%20%20%20%20%20%20%20%20%20%20_X_features%20%3D%20df_modeling%5Bfeature_list%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20scaler_set%20%3D%20StandardScaler()%0A%20%20%20%20%20%20%20%20%20%20%20%20X_scaled_set%20%3D%20scaler_set.fit_transform(_X_features)%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20feature_set_results%20%3D%20%7B%7D%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%23%20Train%20models%20on%20this%20feature%20set%0A%20%20%20%20%20%20%20%20%20%20%20%20for%20model_name%2C%20model%20in%20enhanced_models.items()%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20Skip%20consensus%20model%20if%20not%20using%20consensus%20features%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20model_name%20%3D%3D%20'Random%20Forest%20(Consensus)'%20and%20feature_set_name%20!%3D%20'Consensus%20Features'%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20continue%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20Skip%20primary%20model%20if%20using%20consensus%20features%20(avoid%20duplication)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20model_name%20%3D%3D%20'Random%20Forest%20(Primary)'%20and%20feature_set_name%20%3D%3D%20'Consensus%20Features'%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20continue%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20Create%20fresh%20model%20instance%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20model_instance%20%3D%20type(model)(**model.get_params())%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20Split%20data%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20X_train%2C%20X_test%2C%20y_train%2C%20y_test%20%3D%20train_test_split(%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20X_scaled_set%2C%20_y_target%2C%20test_size%3D0.3%2C%20random_state%3D42%2C%20stratify%3D_y_target%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20)%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20Train%20model%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20model_instance.fit(X_train%2C%20y_train)%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20Predictions%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20y_pred%20%3D%20model_instance.predict(X_test)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20y_prob%20%3D%20model_instance.predict_proba(X_test)%5B%3A%2C%201%5D%20if%20hasattr(model_instance%2C%20'predict_proba')%20else%20y_pred%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20Calculate%20metrics%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20accuracy%20%3D%20accuracy_score(y_test%2C%20y_pred)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20precision%20%3D%20precision_score(y_test%2C%20y_pred%2C%20average%3D'binary'%2C%20zero_division%3D0)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20recall%20%3D%20recall_score(y_test%2C%20y_pred%2C%20average%3D'binary'%2C%20zero_division%3D0)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20f1%20%3D%20f1_score(y_test%2C%20y_pred%2C%20average%3D'binary'%2C%20zero_division%3D0)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20kappa%20%3D%20cohen_kappa_score(y_test%2C%20y_pred)%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20Cross-validation%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20cv_model%20%3D%20type(model)(**model.get_params())%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20cv_scores%20%3D%20cross_val_score(cv_model%2C%20X_scaled_set%2C%20_y_target%2C%20cv%3DStratifiedKFold(5)%2C%20scoring%3D'f1')%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20Out-of-bag%20score%20for%20Random%20Forest%20(Transue%20methodology)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20oob_score%20%3D%20None%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20hasattr(model_instance%2C%20'oob_score_')%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20oob_score%20%3D%20model_instance.oob_score_%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20model_results%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'model'%3A%20model_instance%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'feature_set'%3A%20feature_set_name%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'feature_list'%3A%20feature_list%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'n_features'%3A%20len(feature_list)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'accuracy'%3A%20accuracy%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'precision'%3A%20precision%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'recall'%3A%20recall%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'f1'%3A%20f1%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'kappa'%3A%20kappa%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'cv_f1_mean'%3A%20cv_scores.mean()%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'cv_f1_std'%3A%20cv_scores.std()%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'oob_score'%3A%20oob_score%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'y_test'%3A%20y_test%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'y_pred'%3A%20y_pred%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'y_prob'%3A%20y_prob%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20feature_set_results%5Bmodel_name%5D%20%3D%20model_results%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20Print%20performance%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20performance_str%20%3D%20f%22F1%3D%7Bf1%3A.3f%7D%2C%20Precision%3D%7Bprecision%3A.3f%7D%2C%20Recall%3D%7Brecall%3A.3f%7D%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20oob_score%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20performance_str%20%2B%3D%20f%22%2C%20OOB%3D%7Boob_score%3A.3f%7D%22%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%20%20%20%20%7Bmodel_name%7D%3A%20%7Bperformance_str%7D%22)%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20target_model_results%5Bfeature_set_name%5D%20%3D%20feature_set_results%0A%0A%20%20%20%20%20%20%20%20enhanced_model_results%5B_target_name%5D%20%3D%20target_model_results%0A%0A%20%20%20%20%20%20%20%20%23%20Identify%20best%20performing%20models%20for%20this%20target%0A%20%20%20%20%20%20%20%20print(f%22%5Cn%F0%9F%8F%86%20BEST%20MODELS%20FOR%20%7B_target_name%7D%3A%22)%0A%20%20%20%20%20%20%20%20_best_f1%20%3D%200%0A%20%20%20%20%20%20%20%20best_model_info%20%3D%20None%0A%0A%20%20%20%20%20%20%20%20for%20feature_set_name%2C%20_models%20in%20target_model_results.items()%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20for%20_model_name%2C%20_results%20in%20_models.items()%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20_results%5B'f1'%5D%20%3E%20_best_f1%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20_best_f1%20%3D%20_results%5B'f1'%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20best_model_info%20%3D%20(feature_set_name%2C%20_model_name%2C%20_results)%0A%0A%20%20%20%20%20%20%20%20if%20best_model_info%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20_feature_set%2C%20_model_name%2C%20_results%20%3D%20best_model_info%0A%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%20%20%20%20%7B_model_name%7D%20with%20%7B_feature_set%7D%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%20%20%20%20F1%3A%20%7B_results%5B'f1'%5D%3A.3f%7D%2C%20Features%3A%20%7B_results%5B'n_features'%5D%7D%22)%0A%0A%20%20%20%20print(f%22%5Cn%22%20%2B%20%22%3D%22*70)%0A%20%20%20%20print(%22ENHANCED%20MODEL%20DEVELOPMENT%20COMPLETE%22)%0A%20%20%20%20print(%22%3D%22*70)%0A%20%20%20%20return%20(enhanced_model_results%2C)%0A%0A%0A%40app.cell(hide_code%3DTrue)%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20r%22%22%22%0A%20%20%20%20%23%23%20Enhanced%20Results%20Analysis%20and%20Visualization%0A%0A%20%20%20%20Comprehensive%20analysis%20of%20feature%20selection%20and%20model%20performance%2C%20comparing%20traditional%20and%20Transue%20methodologies.%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(%0A%20%20%20%20comparative_feature_results%2C%0A%20%20%20%20enhanced_model_results%2C%0A%20%20%20%20np%2C%0A%20%20%20%20pd%2C%0A%20%20%20%20plot_dir%2C%0A%20%20%20%20plt%2C%0A%20%20%20%20target_name%2C%0A)%3A%0A%20%20%20%20%23%20Enhanced%20Results%20Analysis%20and%20Visualization%0A%20%20%20%20print(%22ENHANCED%20RESULTS%20ANALYSIS%22)%0A%20%20%20%20print(%22%3D%22*50)%0A%0A%20%20%20%20%23%201.%20Feature%20Selection%20Comparison%20Visualization%0A%20%20%20%20fig%2C%20axes%20%3D%20plt.subplots(2%2C%202%2C%20figsize%3D(15%2C%2012))%0A%0A%20%20%20%20target_names_viz%20%3D%20list(comparative_feature_results.keys())%5B%3A4%5D%20%20%23%20Max%204%20for%20visualization%0A%0A%20%20%20%20for%20_i_viz%2C%20target_name_viz%20in%20enumerate(target_names_viz)%3A%0A%20%20%20%20%20%20%20%20if%20_i_viz%20%3E%3D%204%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20break%0A%0A%20%20%20%20%20%20%20%20ax%20%3D%20axes%5B_i_viz%2F%2F2%2C%20_i_viz%252%5D%0A%20%20%20%20%20%20%20%20target_results_comp%20%3D%20comparative_feature_results%5Btarget_name_viz%5D%0A%0A%20%20%20%20%20%20%20%20%23%20Get%20top%20features%20from%20both%20methods%0A%20%20%20%20%20%20%20%20mi_features%20%3D%20target_results_comp%5B'mutual_information'%5D%5B'rankings'%5D.head(8)%0A%0A%20%20%20%20%20%20%20%20%23%20Plot%20MI%20scores%0A%20%20%20%20%20%20%20%20y_pos%20%3D%20np.arange(len(mi_features))%0A%20%20%20%20%20%20%20%20bars%20%3D%20ax.barh(y_pos%2C%20mi_features%5B'mi_score'%5D%2C%20alpha%3D0.7)%0A%0A%20%20%20%20%20%20%20%20%23%20Color%20bars%20by%20feature%20type%0A%20%20%20%20%20%20%20%20colors%20%3D%20%7B'acoustic_index'%3A%20'steelblue'%2C%20'environmental'%3A%20'orange'%2C%20'temporal'%3A%20'green'%7D%0A%20%20%20%20%20%20%20%20for%20j%2C%20(_%2C%20mi_row)%20in%20enumerate(mi_features.iterrows())%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20bars%5Bj%5D.set_color(colors.get(mi_row%5B'feature_type'%5D%2C%20'gray'))%0A%0A%20%20%20%20%20%20%20%20ax.set_yticks(y_pos)%0A%20%20%20%20%20%20%20%20ax.set_yticklabels(mi_features%5B'feature'%5D%2C%20fontsize%3D8)%0A%20%20%20%20%20%20%20%20ax.set_xlabel('Mutual%20Information%20Score')%0A%20%20%20%20%20%20%20%20ax.set_title(f'%7Btarget_name.replace(%22_%22%2C%20%22%20%22).title()%7D%5CnFeature%20Importance')%0A%20%20%20%20%20%20%20%20ax.grid(True%2C%20alpha%3D0.3%2C%20axis%3D'x')%0A%20%20%20%20%20%20%20%20ax.invert_yaxis()%0A%0A%20%20%20%20%23%20Add%20legend%0A%20%20%20%20handles%20%3D%20%5Bplt.Rectangle((0%2C0)%2C1%2C1%2C%20color%3Dcolors%5Bkey%5D)%20for%20key%20in%20colors.keys()%5D%0A%20%20%20%20labels%20%3D%20%5B'Acoustic%20Index'%2C%20'Environmental'%2C%20'Temporal'%5D%0A%20%20%20%20fig.legend(handles%2C%20labels%2C%20loc%3D'upper%20right'%2C%20bbox_to_anchor%3D(1%2C%201))%0A%0A%20%20%20%20plt.tight_layout()%0A%20%20%20%20plt.savefig(plot_dir%20%2F%20'06_01_enhanced_feature_importance.png'%2C%20dpi%3D150%2C%20bbox_inches%3D'tight')%0A%20%20%20%20plt.show()%0A%0A%20%20%20%20%23%202.%20Model%20Performance%20Comparison%0A%20%20%20%20performance_summary%20%3D%20%5B%5D%0A%0A%20%20%20%20for%20_target_name%2C%20_target_results%20in%20enhanced_model_results.items()%3A%0A%20%20%20%20%20%20%20%20for%20_feature_set%2C%20_models%20in%20_target_results.items()%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20for%20_model_name%2C%20_results%20in%20_models.items()%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20performance_summary.append(%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'target'%3A%20_target_name%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'feature_set'%3A%20_feature_set%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'model'%3A%20_model_name%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'f1'%3A%20_results%5B'f1'%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'precision'%3A%20_results%5B'precision'%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'recall'%3A%20_results%5B'recall'%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'n_features'%3A%20_results%5B'n_features'%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'cv_f1_mean'%3A%20_results%5B'cv_f1_mean'%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D)%0A%0A%20%20%20%20performance_df%20%3D%20pd.DataFrame(performance_summary)%0A%0A%20%20%20%20if%20len(performance_df)%20%3E%200%3A%0A%20%20%20%20%20%20%20%20print(f%22%5CnPerformance%20Summary%3A%22)%0A%20%20%20%20%20%20%20%20print(performance_df.groupby(%5B'model'%2C%20'feature_set'%5D).agg(%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20'f1'%3A%20%5B'mean'%2C%20'std'%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20'n_features'%3A%20'mean'%0A%20%20%20%20%20%20%20%20%7D).round(3))%0A%0A%20%20%20%20%20%20%20%20%23%20Best%20performance%20by%20model%20type%0A%20%20%20%20%20%20%20%20print(f%22%5CnBest%20Performance%20by%20Model%20Type%3A%22)%0A%20%20%20%20%20%20%20%20best_by_model%20%3D%20performance_df.groupby('model')%5B'f1'%5D.max().sort_values(ascending%3DFalse)%0A%20%20%20%20%20%20%20%20for%20_model_name%2C%20_best_f1%20in%20best_by_model.items()%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%20%20%7B_model_name%7D%3A%20%7B_best_f1%3A.3f%7D%22)%0A%0A%20%20%20%20%23%203.%20Feature%20Set%20Performance%20Comparison%0A%20%20%20%20if%20len(performance_df)%20%3E%200%3A%0A%20%20%20%20%20%20%20%20fig%2C%20(ax1%2C%20ax2)%20%3D%20plt.subplots(1%2C%202%2C%20figsize%3D(14%2C%206))%0A%0A%20%20%20%20%20%20%20%20%23%20Performance%20by%20feature%20set%0A%20%20%20%20%20%20%20%20feature_performance%20%3D%20performance_df.groupby('feature_set')%5B'f1'%5D.agg(%5B'mean'%2C%20'std'%5D).sort_values('mean'%2C%20ascending%3DFalse)%0A%0A%20%20%20%20%20%20%20%20ax1.bar(range(len(feature_performance))%2C%20feature_performance%5B'mean'%5D%2C%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20yerr%3Dfeature_performance%5B'std'%5D%2C%20alpha%3D0.7%2C%20capsize%3D5)%0A%20%20%20%20%20%20%20%20ax1.set_xticks(range(len(feature_performance)))%0A%20%20%20%20%20%20%20%20ax1.set_xticklabels(feature_performance.index%2C%20rotation%3D45%2C%20ha%3D'right')%0A%20%20%20%20%20%20%20%20ax1.set_ylabel('Mean%20F1%20Score')%0A%20%20%20%20%20%20%20%20ax1.set_title('Performance%20by%20Feature%20Set')%0A%20%20%20%20%20%20%20%20ax1.grid(True%2C%20alpha%3D0.3%2C%20axis%3D'y')%0A%0A%20%20%20%20%20%20%20%20%23%20Feature%20count%20vs%20performance%0A%20%20%20%20%20%20%20%20ax2.scatter(performance_df%5B'n_features'%5D%2C%20performance_df%5B'f1'%5D%2C%20alpha%3D0.6%2C%20s%3D60)%0A%20%20%20%20%20%20%20%20ax2.set_xlabel('Number%20of%20Features')%0A%20%20%20%20%20%20%20%20ax2.set_ylabel('F1%20Score')%0A%20%20%20%20%20%20%20%20ax2.set_title('Performance%20vs%20Feature%20Count')%0A%20%20%20%20%20%20%20%20ax2.grid(True%2C%20alpha%3D0.3)%0A%0A%20%20%20%20%20%20%20%20plt.tight_layout()%0A%20%20%20%20%20%20%20%20plt.savefig(plot_dir%20%2F%20'06_01_enhanced_performance_comparison.png'%2C%20dpi%3D150%2C%20bbox_inches%3D'tight')%0A%20%20%20%20%20%20%20%20plt.show()%0A%0A%20%20%20%20print(f%22Enhanced%20visualizations%20saved%20to%20%7Bplot_dir%7D%22)%0A%20%20%20%20return%20(performance_df%2C)%0A%0A%0A%40app.cell(hide_code%3DTrue)%0Adef%20_(mo)%3A%0A%20%20%20%20mo.md(%0A%20%20%20%20%20%20%20%20r%22%22%22%0A%20%20%20%20%23%23%20Comprehensive%20Results%20Summary%20and%20Scientific%20Interpretation%0A%0A%20%20%20%20Synthesizing%20findings%20from%20the%20enhanced%20comparative%20analysis%20to%20provide%20actionable%20insights%20for%20biological%20screening.%0A%20%20%20%20%22%22%22%0A%20%20%20%20)%0A%20%20%20%20return%0A%0A%0A%40app.cell%0Adef%20_(%0A%20%20%20%20BORUTA_AVAILABLE%2C%0A%20%20%20%20DATA_ROOT%2C%0A%20%20%20%20comparative_feature_results%2C%0A%20%20%20%20enhanced_model_results%2C%0A%20%20%20%20json%2C%0A%20%20%20%20np%2C%0A%20%20%20%20performance_df%2C%0A%20%20%20%20pickle%2C%0A%20%20%20%20target_name%2C%0A)%3A%0A%20%20%20%20%23%20Comprehensive%20Results%20Summary%0A%20%20%20%20print(%22COMPREHENSIVE%20RESULTS%20SUMMARY%20AND%20SCIENTIFIC%20INTERPRETATION%22)%0A%20%20%20%20print(%22%3D%22*80)%0A%0A%20%20%20%20%23%20Save%20enhanced%20results%0A%20%20%20%20print(%22Saving%20enhanced%20analysis%20results...%22)%0A%0A%20%20%20%20%23%20Save%20comparative%20feature%20results%0A%20%20%20%20with%20open(DATA_ROOT%20%2F%20%22processed%2F06_01_comparative_feature_results.pkl%22%2C%20'wb')%20as%20f%3A%0A%20%20%20%20%20%20%20%20pickle.dump(comparative_feature_results%2C%20f)%0A%0A%20%20%20%20%23%20Save%20enhanced%20model%20results%0A%20%20%20%20with%20open(DATA_ROOT%20%2F%20%22processed%2F06_01_enhanced_model_results.pkl%22%2C%20'wb')%20as%20f%3A%0A%20%20%20%20%20%20%20%20pickle.dump(enhanced_model_results%2C%20f)%0A%0A%20%20%20%20%23%20Create%20comprehensive%20summary%0A%20%20%20%20summary%20%3D%20%7B%0A%20%20%20%20%20%20%20%20'methodology'%3A%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20'boruta_available'%3A%20BORUTA_AVAILABLE%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20'approaches_compared'%3A%20%5B'mutual_information'%2C%20'boruta_random_forest'%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20'models_tested'%3A%20%5B'Random%20Forest%20(Primary)'%2C%20'Logistic%20Regression'%2C%20'Decision%20Tree'%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20'feature_sets_tested'%3A%20%5B'All%20Features'%2C%20'Consensus%20Features'%2C%20'MI%20Top%20Features'%2C%20'Boruta%20Top%20Features'%5D%0A%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20'feature_selection_insights'%3A%20%7B%7D%2C%0A%20%20%20%20%20%20%20%20'model_performance'%3A%20%7B%7D%2C%0A%20%20%20%20%20%20%20%20'scientific_conclusions'%3A%20%7B%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20%23%20Analyze%20feature%20selection%20insights%0A%20%20%20%20print(%22%5Cn1.%20FEATURE%20SELECTION%20INSIGHTS%22)%0A%20%20%20%20print(%22%3D%22*40)%0A%0A%20%20%20%20consensus_summary%20%3D%20%7B%7D%0A%20%20%20%20for%20summary_target_name%2C%20consensus_results%20in%20comparative_feature_results.items()%3A%0A%20%20%20%20%20%20%20%20comparison%20%3D%20consensus_results%5B'comparison'%5D%0A%20%20%20%20%20%20%20%20consensus_rate%20%3D%20comparison%5B'agreement_rate'%5D%0A%0A%20%20%20%20%20%20%20%20consensus_summary%5Btarget_name%5D%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20'agreement_rate'%3A%20consensus_rate%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20'consensus_features'%3A%20comparison%5B'consensus_features'%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20'total_unique_features'%3A%20comparison%5B'total_unique_features'%5D%0A%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20print(f%22%5Cn%7Bsummary_target_name%7D%3A%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20Agreement%20rate%3A%20%7Bconsensus_rate%3A.1%25%7D%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20Consensus%20features%3A%20%7Bcomparison%5B'consensus_features'%5D%7D%22)%0A%0A%20%20%20%20summary%5B'feature_selection_insights'%5D%20%3D%20consensus_summary%0A%0A%20%20%20%20%23%20Analyze%20model%20performance%0A%20%20%20%20print(f%22%5Cn2.%20MODEL%20PERFORMANCE%20ANALYSIS%22)%0A%20%20%20%20print(%22%3D%22*35)%0A%0A%20%20%20%20if%20len(performance_df)%20%3E%200%3A%0A%20%20%20%20%20%20%20%20%23%20Best%20overall%20performance%0A%20%20%20%20%20%20%20%20best_overall%20%3D%20performance_df.loc%5Bperformance_df%5B'f1'%5D.idxmax()%5D%0A%20%20%20%20%20%20%20%20print(f%22%5CnBest%20Overall%20Performance%3A%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20Model%3A%20%7Bbest_overall%5B'model'%5D%7D%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20Feature%20Set%3A%20%7Bbest_overall%5B'feature_set'%5D%7D%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20Target%3A%20%7Bbest_overall%5B'target'%5D%7D%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20F1%20Score%3A%20%7Bbest_overall%5B'f1'%5D%3A.3f%7D%22)%0A%20%20%20%20%20%20%20%20print(f%22%20%20Features%20Used%3A%20%7Bbest_overall%5B'n_features'%5D%7D%22)%0A%0A%20%20%20%20%20%20%20%20%23%20Random%20Forest%20performance%20(Transue%20methodology%20focus)%0A%20%20%20%20%20%20%20%20performance_rf_results%20%3D%20performance_df%5Bperformance_df%5B'model'%5D.str.contains('Random%20Forest')%5D%0A%20%20%20%20%20%20%20%20if%20len(performance_rf_results)%20%3E%200%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20rf_mean_performance%20%3D%20performance_rf_results.groupby('feature_set')%5B'f1'%5D.mean()%0A%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%5CnRandom%20Forest%20Performance%20by%20Feature%20Set%3A%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20for%20feature_set%2C%20mean_f1%20in%20rf_mean_performance.sort_values(ascending%3DFalse).items()%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%20%20%7Bfeature_set%7D%3A%20%7Bmean_f1%3A.3f%7D%22)%0A%0A%20%20%20%20%20%20%20%20%23%20Feature%20set%20effectiveness%0A%20%20%20%20%20%20%20%20feature_set_performance%20%3D%20performance_df.groupby('feature_set')%5B'f1'%5D.agg(%5B'mean'%2C%20'count'%5D).sort_values('mean'%2C%20ascending%3DFalse)%0A%20%20%20%20%20%20%20%20print(f%22%5CnFeature%20Set%20Effectiveness%3A%22)%0A%20%20%20%20%20%20%20%20for%20_feature_set%2C%20(mean_f1%2C%20count)%20in%20feature_set_performance.iterrows()%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20print(f%22%20%20%7B_feature_set%7D%3A%20%7Bmean_f1%3A.3f%7D%20(n%3D%7Bcount%7D)%22)%0A%0A%20%20%20%20%20%20%20%20summary%5B'model_performance'%5D%20%3D%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20'best_overall'%3A%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'model'%3A%20best_overall%5B'model'%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'feature_set'%3A%20best_overall%5B'feature_set'%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'target'%3A%20best_overall%5B'target'%5D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'f1_score'%3A%20float(best_overall%5B'f1'%5D)%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20'n_features'%3A%20int(best_overall%5B'n_features'%5D)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20'random_forest_by_features'%3A%20%7Bk%3A%20float(v)%20for%20k%2C%20v%20in%20rf_mean_performance.items()%7D%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20'feature_set_rankings'%3A%20%7Bk%3A%20float(v%5B'mean'%5D)%20for%20k%2C%20v%20in%20feature_set_performance.iterrows()%7D%0A%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%23%20Scientific%20conclusions%0A%20%20%20%20print(f%22%5Cn3.%20SCIENTIFIC%20CONCLUSIONS%22)%0A%20%20%20%20print(%22%3D%22*30)%0A%0A%20%20%20%20conclusions%20%3D%20%5B%5D%0A%0A%20%20%20%20%23%20Methodology%20comparison%20conclusion%0A%20%20%20%20if%20BORUTA_AVAILABLE%3A%0A%20%20%20%20%20%20%20%20avg_consensus_rate%20%3D%20np.mean(%5Bres%5B'agreement_rate'%5D%20for%20res%20in%20consensus_summary.values()%5D)%0A%20%20%20%20%20%20%20%20if%20avg_consensus_rate%20%3E%200.6%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20conclusions.append(f%22%E2%9C%85%20High%20agreement%20between%20MI%20and%20Boruta%20methods%20(%7Bavg_consensus_rate%3A.1%25%7D%20average%20consensus)%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20conclusions.append(%22Recommendation%3A%20Focus%20on%20consensus%20features%20for%20most%20robust%20biological%20screening%22)%0A%20%20%20%20%20%20%20%20elif%20avg_consensus_rate%20%3E%200.4%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20conclusions.append(f%22%E2%9A%A0%EF%B8%8F%20Moderate%20agreement%20between%20methods%20(%7Bavg_consensus_rate%3A.1%25%7D%20average%20consensus)%22)%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20conclusions.append(%22Recommendation%3A%20Use%20both%20approaches%20to%20capture%20different%20aspects%20of%20biological%20patterns%22)%0A%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20conclusions.append(f%22%E2%9D%8C%20Low%20agreement%20between%20methods%20(%7Bavg_consensus_rate%3A.1%25%7D%20average%20consensus)%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20conclusions.append(%22Recommendation%3A%20Investigate%20why%20methods%20disagree%20-%20may%20indicate%20complex%20biological%20relationships%22)%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20conclusions.append(%22%E2%9A%A0%EF%B8%8F%20Boruta%20analysis%20not%20available%20-%20using%20MI%20%2B%20Random%20Forest%20importance%20for%20feature%20selection%22)%0A%20%20%20%20%20%20%20%20conclusions.append(%22Recommendation%3A%20Install%20Boruta%20package%20for%20full%20Transue%20methodology%20implementation%22)%0A%0A%20%20%20%20%23%20Performance%20conclusions%0A%20%20%20%20if%20len(performance_df)%20%3E%200%3A%0A%20%20%20%20%20%20%20%20_best_f1%20%3D%20performance_df%5B'f1'%5D.max()%0A%20%20%20%20%20%20%20%20if%20_best_f1%20%3E%200.8%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20conclusions.append(f%22%E2%9C%85%20Excellent%20model%20performance%20achieved%20(F1%3D%7B_best_f1%3A.3f%7D)%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20conclusions.append(%22Recommendation%3A%20Models%20ready%20for%20biological%20screening%20deployment%22)%0A%20%20%20%20%20%20%20%20elif%20_best_f1%20%3E%200.7%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20conclusions.append(f%22%E2%9C%85%20Good%20model%20performance%20achieved%20(F1%3D%7B_best_f1%3A.3f%7D)%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20conclusions.append(%22Recommendation%3A%20Models%20suitable%20for%20biological%20screening%20with%20careful%20validation%22)%0A%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20conclusions.append(f%22%E2%9A%A0%EF%B8%8F%20Moderate%20model%20performance%20(F1%3D%7B_best_f1%3A.3f%7D)%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20conclusions.append(%22Recommendation%3A%20Consider%20additional%20feature%20engineering%20or%20data%20collection%22)%0A%0A%20%20%20%20%23%20Feature%20efficiency%20conclusions%0A%20%20%20%20if%20'Consensus%20Features'%20in%20performance_df%5B'feature_set'%5D.values%3A%0A%20%20%20%20%20%20%20%20consensus_performance%20%3D%20performance_df%5Bperformance_df%5B'feature_set'%5D%20%3D%3D%20'Consensus%20Features'%5D%5B'f1'%5D.mean()%0A%20%20%20%20%20%20%20%20all_features_performance%20%3D%20performance_df%5Bperformance_df%5B'feature_set'%5D%20%3D%3D%20'All%20Features'%5D%5B'f1'%5D.mean()%0A%0A%20%20%20%20%20%20%20%20if%20consensus_performance%20%3E%3D%20all_features_performance%20*%200.95%3A%20%20%23%20Within%205%25%20of%20full%20performance%0A%20%20%20%20%20%20%20%20%20%20%20%20avg_consensus_features%20%3D%20performance_df%5Bperformance_df%5B'feature_set'%5D%20%3D%3D%20'Consensus%20Features'%5D%5B'n_features'%5D.mean()%0A%20%20%20%20%20%20%20%20%20%20%20%20conclusions.append(f%22%E2%9C%85%20Consensus%20features%20maintain%20%7Bconsensus_performance%2Fall_features_performance%3A.1%25%7D%20of%20full%20performance%20with%20%7Bavg_consensus_features%3A.0f%7D%20features%22)%0A%20%20%20%20%20%20%20%20%20%20%20%20conclusions.append(%22Recommendation%3A%20Use%20consensus%20feature%20set%20for%20efficient%20biological%20screening%22)%0A%0A%20%20%20%20for%20_i_conc%2C%20conclusion%20in%20enumerate(conclusions%2C%201)%3A%0A%20%20%20%20%20%20%20%20print(f%22%20%20%7B_i_conc%7D.%20%7Bconclusion%7D%22)%0A%0A%20%20%20%20summary%5B'scientific_conclusions'%5D%20%3D%20conclusions%0A%0A%20%20%20%20%23%20Save%20summary%0A%20%20%20%20with%20open(DATA_ROOT%20%2F%20%22processed%2F06_01_enhanced_analysis_summary.json%22%2C%20'w')%20as%20f%3A%0A%20%20%20%20%20%20%20%20json.dump(summary%2C%20f%2C%20indent%3D2)%0A%0A%20%20%20%20print(f%22%5Cn%22%20%2B%20%22%3D%22*80)%0A%20%20%20%20print(%22ENHANCED%20COMMUNITY%20PATTERN%20DETECTION%20ANALYSIS%20COMPLETE%22)%0A%20%20%20%20print(%22%3D%22*80)%0A%20%20%20%20print(f%22%E2%9C%85%20Comparative%20feature%20selection%20completed%22)%0A%20%20%20%20print(f%22%E2%9C%85%20Enhanced%20model%20validation%20completed%22)%0A%20%20%20%20print(f%22%E2%9C%85%20Scientific%20conclusions%20documented%22)%0A%20%20%20%20print(f%22%E2%9C%85%20Results%20saved%20for%20biological%20screening%20deployment%22)%0A%0A%20%20%20%20if%20BORUTA_AVAILABLE%3A%0A%20%20%20%20%20%20%20%20print(f%22%F0%9F%8C%B2%20Boruta%20methodology%20successfully%20integrated%22)%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20print(f%22%E2%9A%A0%EF%B8%8F%20Install%20Boruta%20package%20for%20full%20Transue%20methodology%3A%20pip%20install%20boruta%22)%0A%0A%20%20%20%20print(%22%3D%22*80)%0A%20%20%20%20return%0A%0A%0Aif%20__name__%20%3D%3D%20%22__main__%22%3A%0A%20%20%20%20app.run()%0A
</marimo-code>

<marimo-code-hash hidden="">ef1573a1c7460dc8cf395a277f177edff63963763e777c24b1228cb237cbcee1</marimo-code-hash>
</body>
</html>
